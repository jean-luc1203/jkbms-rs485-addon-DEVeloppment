[
    {
        "id": "0f3c5bd285141d40",
        "type": "tab",
        "label": "Warning - Avertissement",
        "disabled": false,
        "info": ""
    },
    {
        "id": "b1ca67b21089b915",
        "type": "tab",
        "label": "Initialisations",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "ce01fabde0618f55",
        "type": "tab",
        "label": "Lecture RS485",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "348d851bc48bb663",
        "type": "tab",
        "label": "Setup RS485",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7eba58462314a0d7",
        "type": "tab",
        "label": "Lecture Broadascting RS485",
        "disabled": false,
        "info": "Dans ce cas, il y a un des BMS qui est \r\ndéfini en maitre du bus rs485. C'est lui \r\nqui va aller demander les informations aux\r\nautres BMS.\r\nDans cette configuration, on ne peut pas\r\nchanger les paramètres car il ne peut pas\r\ny avoir 2 Master sur le bus en modbus.",
        "env": []
    },
    {
        "id": "2e99fd421b434bcb",
        "type": "tab",
        "label": "CAN bus",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "44f1a774d989bad2",
        "type": "tab",
        "label": "bip",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "e046a6ce6457b012",
        "type": "tab",
        "label": "Dashboard",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "6fc9763d4087338c",
        "type": "subflow",
        "name": "Subflow 1",
        "info": "",
        "category": "",
        "in": [],
        "out": [],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "0693b9727dec471d",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Phase initialisation & lecture automatique (1 seule demande modbus)",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "d84c3f32b5bee13a",
            "1430199873abea94",
            "9df6cb4f228ce42d",
            "61eadd92484325e7",
            "a3bd0a6eeb93d67f",
            "074c128ffe1701e8",
            "935c37a416cb0336",
            "a632bb3545ad81d5",
            "389031f7d149d0e4",
            "bbfdd16be70fd7b0",
            "b7c41933feffd518",
            "7fc90ebca81725ca",
            "3f472b31a16a5124",
            "5d8b1329cf980408",
            "73cf0d220e1de798",
            "e45ebcb6cea88b4b",
            "3782b34f573f61fe",
            "02768681f22fb273"
        ],
        "x": 14,
        "y": 519,
        "w": 1222,
        "h": 282
    },
    {
        "id": "9c42cd07964fe992",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Port Série Out",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#000000",
            "fill": "#ffbfbf"
        },
        "nodes": [
            "19e4f82b41b8041a",
            "5e23433b1e088edf",
            "9fb62a629d09612b",
            "47ab0322cedc3c22",
            "54c93e67707946a8",
            "29aa81cab8e98225"
        ],
        "x": 54,
        "y": 339,
        "w": 512,
        "h": 122
    },
    {
        "id": "1bb1485c6f644ee6",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Décodage des trames 1 - 2 - 3",
        "style": {
            "stroke": "#ffC000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "bff0d4fab3ef46a5",
            "2e57321f85689f45",
            "c06c156ddb36634e",
            "e17a26b0d2bf5039",
            "dd313e0f9fd4ef67",
            "9e766385cf7c92f6"
        ],
        "x": 16,
        "y": 893,
        "w": 1436,
        "h": 994
    },
    {
        "id": "18188dc49c4fd89a",
        "type": "group",
        "z": "348d851bc48bb663",
        "name": "Lecture des setup arrivant depuis HAOS",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "02dd5257a29af5a6",
            "aa260e367192285d",
            "81acf21e86521b86",
            "d9252d611463a606",
            "32701e033c9ee445",
            "8f82452292423562",
            "d866e088f62e39db",
            "f446b30dc2078f42",
            "223504123cb3206a",
            "3b20d857112c188b",
            "0feab4f81e28026c",
            "37a35ec9033764b1",
            "b6ad66b9c7594229",
            "0e879f0b1033923c"
        ],
        "x": 14,
        "y": 59,
        "w": 842,
        "h": 242
    },
    {
        "id": "0bbb61cb5f6504ae",
        "type": "group",
        "z": "348d851bc48bb663",
        "name": "Write Setup Valeurs",
        "style": {
            "stroke": "#6f2fa0",
            "label": true,
            "color": "#6f2fa0"
        },
        "nodes": [
            "133adc320649ffd0",
            "1b9d270fb278785c",
            "0f8129c7962fb889",
            "5132d56fbde6fce4",
            "9cdaf1add7c8c49f",
            "5818d18351e2505a",
            "e1f20160d6873a16",
            "831223922b6e7a42",
            "fd1c6b82e6f4c66b",
            "bb7a17a27dd64e00",
            "bceacd21b82896e0",
            "c84672a0371bb1cc",
            "57c093189c8bb8cb",
            "bd140493b7942afa",
            "3317efd75feda45f",
            "edda4776590c41a7",
            "c2528c16e766563a",
            "666ac34f65df37fe",
            "c939f58b7a5ce3a1",
            "b9c43c59d83a114b",
            "834f13ebf4e4b0aa",
            "a08c1b9678760404",
            "9877b4d7a594f576",
            "57a2d5e590849c4c",
            "b2b2a91d76d8b8ef",
            "070294cbb6631c51",
            "18100f82ea9b96e2",
            "82a079d96e716dfb",
            "a2d933bf5714917f",
            "f69bb43232dd2c3b",
            "e1b5d6daa74cc917",
            "10d7690719c5a734",
            "ca1db571bf48ece1",
            "25bbb554698f3085",
            "d4b59e37e854b67d",
            "4782063a6f4cbb89",
            "b545eac4a5a827f8",
            "b997b486b520ba66",
            "969bfbdc6ff80482",
            "842d499ea9fe3f9c",
            "830726d692b9c886",
            "b4210ea0e3eceeca",
            "19813c881712a20f",
            "1d8951e6d5cadaac",
            "631dc32357e54b02",
            "4077be501625201b",
            "54b01d2a7d5b9841",
            "1c9fa4df6d24ab3c",
            "14c2982fd6b4b10b",
            "c2a965eb88a133a6"
        ],
        "x": 54,
        "y": 419,
        "w": 932,
        "h": 1562
    },
    {
        "id": "4cfdd0fab949bb3c",
        "type": "group",
        "z": "b1ca67b21089b915",
        "name": "Configuration du port USB RS485",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "36ac99672d282e93",
            "00678a50f9f3ef9c",
            "0c9baa364697bbfe",
            "df5482d67ec293f9",
            "49c92598895378e1"
        ],
        "x": 14,
        "y": 359,
        "w": 1052,
        "h": 82
    },
    {
        "id": "d9178a09ade71024",
        "type": "group",
        "z": "b1ca67b21089b915",
        "name": "Initialisation des variables",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "3fba971ea0547c66",
            "3ecb0dcd9663050d",
            "c8e26f4ca5e76e36"
        ],
        "x": 8,
        "y": 19,
        "w": 1064,
        "h": 308
    },
    {
        "id": "c1fd93cd8f38ea7c",
        "type": "group",
        "z": "b1ca67b21089b915",
        "name": "MQTT définitions",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "0c319b0244658cad",
            "80a0031e2a8dbfbc",
            "355fec0a2e1aaf7a",
            "b82078ca27edc9db",
            "58adbc8abf20aab0",
            "4e25b5fa6500606e",
            "66ce0bd5261eb149",
            "63efeee1a97e3bb9",
            "323bc1fdf8eb4b0e",
            "468d5c1a95681d8d"
        ],
        "x": 14,
        "y": 479,
        "w": 772,
        "h": 182
    },
    {
        "id": "fcf5dd3bc6e97b81",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Gateway Ethernet or Wifi",
        "style": {
            "stroke": "#0070c0",
            "fill": "#bfdbef",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "f1e5252af3527154",
            "55581e8fd2063a3b",
            "5f1cc6f02653dd86",
            "03d54d1f353534ca",
            "72408cddd3840bf2",
            "b2892effe9f79e84",
            "fbd3591a98eafd6d",
            "3de40e166b34cd30",
            "8c17e9b0cc52aac4"
        ],
        "x": 634,
        "y": 279,
        "w": 602,
        "h": 182
    },
    {
        "id": "71ff535abf2657b3",
        "type": "group",
        "z": "7eba58462314a0d7",
        "name": "Port Série Out",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#000000",
            "fill": "#ffbfbf",
            "fill-opacity": "0.21"
        },
        "nodes": [
            "24f7bb18c1109510",
            "a760f49cb3f03843",
            "b28c235f729ec2af",
            "d2613e804a5c9e0d",
            "41542c3844b4344a",
            "cc1ee5cb46e0c0b3",
            "cdc3910800c7d95b",
            "76ddac3ef98c9d5f"
        ],
        "x": 44,
        "y": 479,
        "w": 962,
        "h": 162
    },
    {
        "id": "09da833fe1650dca",
        "type": "group",
        "z": "7eba58462314a0d7",
        "name": "Décodage des trames \"setup\" & \"data\"",
        "style": {
            "stroke": "#ffC000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "b75a55c2aaa3b2b6",
            "a1697c874f4c5e2d",
            "c7bb4746ce710cb1"
        ],
        "x": 48,
        "y": 693,
        "w": 1004,
        "h": 654
    },
    {
        "id": "6c19eb9e84cdf38b",
        "type": "group",
        "z": "b1ca67b21089b915",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "0ec51b6fd8d48038",
            "84db6ed2a0945bdd",
            "a0a0d9469406c5a8",
            "b38da9cc0fe45944",
            "18be8868fd9888b7",
            "567fe9a7f3910323",
            "32d98207bb37887d",
            "9d3d9cd9d0aaf884",
            "ea424593a0b6533a",
            "4a6179de378fa7c5",
            "6fa5d0c215b7e641",
            "8bcf0e0b17b0565f"
        ],
        "x": 34,
        "y": 979,
        "w": 492,
        "h": 282
    },
    {
        "id": "09c8d74836111377",
        "type": "group",
        "z": "b1ca67b21089b915",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "2f1946e570f89af5",
            "4b621344460ef394"
        ],
        "x": 574,
        "y": 1089.199951171875,
        "w": 312,
        "h": 131.800048828125
    },
    {
        "id": "8db7330998795c6b",
        "type": "group",
        "z": "7eba58462314a0d7",
        "name": "Check si on est en position broadcast sur le JKBMS Master et si on utilise le Gateway Ethernet or Wifi. Si oui, il faut établir une fois la connexion IP",
        "style": {
            "stroke": "#0070c0",
            "fill": "#bfdbef",
            "label": true,
            "color": "#000000",
            "fill-opacity": "0.21"
        },
        "nodes": [
            "54f13db307ef04c6",
            "44c1946af35b4bf2",
            "ac5e2007494e8ec7",
            "39deea4e80f940dc",
            "36740c8949df9213",
            "9065a93867dab80e",
            "73d8b350243362a9",
            "312ad2b56727f9b0",
            "69b1ce57af6c5821",
            "17af908365d66c64",
            "7c34c27efa97726a"
        ],
        "x": 14,
        "y": 259,
        "w": 1272,
        "h": 182
    },
    {
        "id": "d03facb97e5d14d1",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "CAN read",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#ff0000"
        },
        "nodes": [
            "c3de74fe6e67e34d",
            "3228a87076560c09",
            "b1930c0f7c133e97",
            "0efe20eac7430343",
            "edddd5764795e5e8",
            "a382ef9233e091ce",
            "3468acfdfe712e73",
            "f42caadb5356ae1d"
        ],
        "x": 34,
        "y": 339,
        "w": 952,
        "h": 162
    },
    {
        "id": "1d5b0e71e0a2eba5",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Up & Down & Bit rate",
        "style": {
            "label": true
        },
        "nodes": [
            "0ef8fc221e14acf6",
            "bfc557c471275022",
            "ab0eed874c8d277a",
            "505be46f8eda2768",
            "f73071ac18154111",
            "f5dfca4e639fa942",
            "876fccdff470c9e9",
            "7dc27bfd806f5368",
            "c3b71c2f1a714c85",
            "64ae959294b9f406",
            "4b1f866ae32190f9",
            "ac59461acfb2cc71"
        ],
        "x": 734,
        "y": 1439,
        "w": 752,
        "h": 322
    },
    {
        "id": "2584ccec0ec42693",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "CAN décodage",
        "style": {
            "stroke": "#ffff00",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "db723bbce9cd2eb7",
            "427020bec4bb2db0",
            "cf375bcb018ce6c2",
            "c2369537eb2295bb",
            "2a10c4fd52fdcdbf",
            "f28c4eb22257478c",
            "b84f87970c11f14e",
            "e7576279e8153b1b",
            "80a3b32d9f0f0730",
            "8603c29f2c2105d4",
            "7821b4f3d5cbe3df",
            "0a5f6e32247b194d",
            "75044b278b31a047",
            "89d6590a094825e7",
            "788e057cc57fcb4c",
            "ed8a4b44d9f1a840",
            "c955aacbd7372820",
            "33664bc1723b2cde",
            "8c4ae23f7fadd63d",
            "cf27fc9e687cec75",
            "ecea4cb337311c7f",
            "5db3845569e2eacb",
            "21eb77fc0deb7df8",
            "91aacf4dfc2f6b45",
            "8144d8148f4c0840",
            "1daa9e6390671ea8",
            "72b36b4609b42dba",
            "0005b67220843057",
            "9de87061f754ddf9",
            "b188deca5d12b002"
        ],
        "x": 34,
        "y": 539,
        "w": 1058,
        "h": 768
    },
    {
        "id": "ccc1258cc5051fb2",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Show",
        "style": {
            "label": true
        },
        "nodes": [
            "0d119ba5972c169a",
            "91b2a628817de544",
            "e568cd8b91c96fff",
            "19e2a3758a49f532"
        ],
        "x": 734,
        "y": 1819,
        "w": 582,
        "h": 122
    },
    {
        "id": "9ca59e5665a543ec",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Pour debug only",
        "style": {
            "stroke": "#a4a4a4",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "459611fc12f08799",
            "70175f15e3a96645",
            "851759d8657506d7",
            "a11b6d0e18d66357",
            "cc70f856bb715e58",
            "5832fe6540f56826",
            "cc58661e52c4af01",
            "0114fcc43bfd35e2",
            "a518317b59bd58da",
            "5c3517a74be5a7e7",
            "840d9bc33fc7e3e4",
            "49530b441302aacc",
            "0d4939b7cbb31bb3",
            "156de1e34b3811c8",
            "646f282c0dd63a6e"
        ],
        "x": 34,
        "y": 1339,
        "w": 638,
        "h": 722
    },
    {
        "id": "c002b2b718abc28f",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Initialisation de l'interface",
        "style": {
            "stroke": "#6f2fa0",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "5cfaee00ed1d945e",
            "93acca2bdf879a01",
            "81797f8435ea4090",
            "33e185e362f95f82",
            "d09a3cc293255be2",
            "4c7382e365ab7a48",
            "b3cc6af46b5e8003",
            "b5fefa24fa332bb0",
            "a1212ebb1907b570",
            "89480d3fdae61266",
            "606759ae352bbf73",
            "918a82299c32dcf9"
        ],
        "x": 34,
        "y": 19,
        "w": 852,
        "h": 269.5
    },
    {
        "id": "fcb249897b0ead9e",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Globale Variable change",
        "style": {
            "stroke": "#bfdbef",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "69e938ba030b7546",
            "795828b453f64b9b",
            "748d73da83bca2cf",
            "b30c7fb6356f631e"
        ],
        "x": 914,
        "y": 59,
        "w": 472,
        "h": 122
    },
    {
        "id": "ce6083697fa14dc0",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Debug des données",
        "style": {
            "stroke": "#007000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "993c2383b70be9f1",
            "0b8826e5e66ac591",
            "898dd8cf77551382",
            "9cd19b0cda3b295b",
            "4c96f83e2c664c74",
            "276f29f9528f1322",
            "a4215bec9779ed8c",
            "3c1b49123cabedb0",
            "8eea8a8ef9220c22"
        ],
        "x": 294,
        "y": 1919,
        "w": 712,
        "h": 242
    },
    {
        "id": "e09fcfa37fa58cc8",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Envoi des commandes Setup vers le port série ou IP",
        "style": {
            "stroke": "#92d04f",
            "label": true,
            "color": "#6f2fa0",
            "fill": "#c8e7a7",
            "fill-opacity": "0.37"
        },
        "nodes": [
            "fa351cb08a5d02e9",
            "bb64089a3c76b396",
            "0e2831f9e2a8e7cf",
            "6542c8ba28167fbf"
        ],
        "x": 814,
        "y": 59,
        "w": 334,
        "h": 122
    },
    {
        "id": "54c718657c13c657",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "ESSAIS To show RCV and RFV values in 'hours' instead of 'seconds' ",
        "style": {
            "label": true
        },
        "nodes": [
            "1401504164e95430",
            "1a8ddebb594458ae",
            "9b436a73a13b0cb3",
            "ea5c7b5329c945a4",
            "5ea27536ce8688a6",
            "2b4bee671f623f3c",
            "94d92b48b836576f",
            "58a120471d8b3aa5"
        ],
        "x": 64,
        "y": 2219,
        "w": 762,
        "h": 162
    },
    {
        "id": "fc42763da6defab8",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Permet de ne faire qu'une seule passe pour les  discovery topic de HAOS",
        "style": {
            "label": true
        },
        "nodes": [
            "8666d6cf3f8a75cc",
            "bd13172ab7887f84",
            "5b29999d7fdc4120",
            "e77b486cbdcfe2b9",
            "7020aefa46e32f74",
            "90d3a2c04fa2bc90"
        ],
        "x": 34,
        "y": 19,
        "w": 652,
        "h": 242
    },
    {
        "id": "2a96ca484e0815bf",
        "type": "group",
        "z": "7eba58462314a0d7",
        "name": "Initialisation Flags discovery",
        "style": {
            "stroke": "#92d04f",
            "fill": "#e3f3d3",
            "fill-opacity": "0.18",
            "label": true,
            "color": "#001f60",
            "label-position": "n"
        },
        "nodes": [
            "7bdc72b0af93d76a",
            "b47fc264732cec08"
        ],
        "x": 614,
        "y": 59,
        "w": 412,
        "h": 82
    },
    {
        "id": "a3a21b2242312efd",
        "type": "group",
        "z": "7eba58462314a0d7",
        "name": "Gestion des Alarmes BMS en mode broadcasting",
        "style": {
            "stroke": "#ff0000",
            "fill": "#ffbfbf",
            "fill-opacity": "0.19",
            "label": true,
            "label-position": "n",
            "color": "#000000"
        },
        "nodes": [
            "7d85cec3b8e788bf",
            "c61f13fa51886e67",
            "4718ccede024f711",
            "582e23a67b8ce434",
            "568cf4c923b7c5bd",
            "3f01427254d074d7",
            "c9cbac907c0d0ae7",
            "aeb356a830532d6c",
            "92b1d01fa81c4af0"
        ],
        "x": 54,
        "y": 1379,
        "w": 1012,
        "h": 142
    },
    {
        "id": "0bab67838083522a",
        "type": "group",
        "z": "b1ca67b21089b915",
        "name": "URL Dashboard Node Red",
        "style": {
            "label": true,
            "stroke": "#0070c0",
            "color": "#001f60"
        },
        "nodes": [
            "691f43464b1625d9",
            "e05d7ff558a4dbae",
            "7060e96cd73705af"
        ],
        "x": 24,
        "y": 699,
        "w": 642,
        "h": 82
    },
    {
        "id": "f382b31e2c58e8c3",
        "type": "group",
        "z": "e046a6ce6457b012",
        "name": "Dashboard Live Data",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "90589e2e759450b0",
            "72858cb8135ecca1",
            "6c3251dbb536e412",
            "4669a15e5fbce50a"
        ],
        "x": 304,
        "y": 339,
        "w": 842,
        "h": 82
    },
    {
        "id": "76fabc0223d5e539",
        "type": "group",
        "z": "e046a6ce6457b012",
        "name": "Dashboard Static Data",
        "style": {
            "label": true,
            "stroke": "#001f60",
            "color": "#001f60"
        },
        "nodes": [
            "41569635140450b8",
            "3f54927a8562ef8c",
            "88076e010f936d8b",
            "09f010af7c5e1992"
        ],
        "x": 154,
        "y": 59,
        "w": 872,
        "h": 82
    },
    {
        "id": "3eae94408690a564",
        "type": "group",
        "z": "44f1a774d989bad2",
        "name": "Check OS type",
        "style": {
            "stroke": "#92d04f",
            "label": true,
            "color": "#ff0000"
        },
        "nodes": [
            "inject_startup_v2",
            "exec_test_os",
            "switch_os",
            "set_windows",
            "exec_detect_linux_detail",
            "parse_env_v2",
            "file_read_v2",
            "parse_json_v2",
            "debug_config_v2",
            "72f87905871f38b0",
            "c0a1550183f24e9b",
            "7d18ea54123e1414",
            "4c19e94f627591cd",
            "4b5571fbcfbfbc8c"
        ],
        "x": 114,
        "y": 119,
        "w": 1112,
        "h": 302
    },
    {
        "id": "3909cc6b3670d838",
        "type": "group",
        "z": "e046a6ce6457b012",
        "name": "Dashboard Settings Data",
        "style": {
            "stroke": "#0070c0",
            "label": true,
            "color": "#0070c0"
        },
        "nodes": [
            "1dc7d19597d60885",
            "73a9586798828b06",
            "87a73731e478e29a",
            "020632fc8339b4f3"
        ],
        "x": 214,
        "y": 199,
        "w": 892,
        "h": 82
    },
    {
        "id": "646f282c0dd63a6e",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "g": "9ca59e5665a543ec",
        "name": "16 Cell's volatge",
        "style": {
            "stroke": "#92d04f",
            "label": true
        },
        "nodes": [
            "181f7ced3cb4faf7",
            "8264c8cacce70110",
            "95ae122462034c80",
            "890d83e4ddd29134"
        ],
        "x": 294,
        "y": 1619,
        "w": 352,
        "h": 202
    },
    {
        "id": "9de87061f754ddf9",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "16 Cell's volatge",
        "style": {
            "stroke": "#92d04f",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "59a32da84f1d558f",
            "6012cd81c0bcf535",
            "7052b31a5e638f20",
            "13609daae25e3257",
            "52d83545146677d4",
            "5902f421447b046d",
            "e78e87fb719b450d",
            "c50f23a0e0297de8",
            "1b8d8f8af7b7474f",
            "7d97f7131d3497a0",
            "32e8d6abd9ac44d0",
            "740e7dc1d40c5efa",
            "4be4303ae0f078dc"
        ],
        "x": 234,
        "y": 819,
        "w": 832,
        "h": 202
    },
    {
        "id": "b188deca5d12b002",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "To MQTT Broker",
        "style": {
            "label": true,
            "stroke": "#0070c0",
            "fill": "#e3f3d3",
            "color": "#000000"
        },
        "nodes": [
            "7cdddbdff16d1585",
            "f491a2b292a65e24"
        ],
        "x": 704,
        "y": 1199,
        "w": 222,
        "h": 82
    },
    {
        "id": "c8e26f4ca5e76e36",
        "type": "group",
        "z": "b1ca67b21089b915",
        "g": "d9178a09ade71024",
        "name": "Récupération des variables définies dans la configuration du module depuis l'onglet configuration de HAOS",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "12543920bca0a8e5",
            "5c144e0e135713c7",
            "9db46980e482d881",
            "2682276da62a0840",
            "b122ec506872171a",
            "416789eaf381cb09"
        ],
        "x": 34,
        "y": 179,
        "w": 1012,
        "h": 122
    },
    {
        "id": "bff0d4fab3ef46a5",
        "type": "group",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Trame 1 - Specifications statiques",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#777777",
            "fill": "#d1d1d1",
            "fill-opacity": "0.26"
        },
        "nodes": [
            "b2d928a2b649fe63",
            "bbe7f5ddcea331a9",
            "264d6f5686cf22f1",
            "7a45939101576456",
            "2492d95ecc9f328c",
            "32a6b862b301b073",
            "cb1a7697e8293f75",
            "1c51761e84ee5bb2",
            "dab766c54a57452d",
            "c054e6c82bc4bb0a",
            "6ca55c256080e1c0",
            "73bb9117fd0b3a8e",
            "32f3c0d652235f1c"
        ],
        "x": 44,
        "y": 1119,
        "w": 1382,
        "h": 122
    },
    {
        "id": "2e57321f85689f45",
        "type": "group",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Trame 3 - Data des BMS en live",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#0070c0",
            "fill": "#bfdbef",
            "fill-opacity": "0.31"
        },
        "nodes": [
            "a6b1b65a3e856d8f",
            "4c893435cad6711e",
            "c0f222bb926bd319",
            "d8f9f00da2e3a338",
            "97a3abc79a4c67cd",
            "60a06da8cc236522",
            "c6f86ca54e23c581",
            "15033939a61ddd92",
            "705a77e3b053f7ca",
            "00cca2d92bf02b99",
            "884c969712f9982d",
            "914fc4cee6ebe7ee",
            "8756d698a33880b8"
        ],
        "x": 42,
        "y": 1499,
        "w": 1384,
        "h": 122
    },
    {
        "id": "c06c156ddb36634e",
        "type": "group",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Trame 2 - Settings des BMS",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#ff0000",
            "fill": "#ffffbf",
            "fill-opacity": "0.39"
        },
        "nodes": [
            "867fca3b9f77ce27",
            "3987f9e640e885a6",
            "dde116783a665a3f",
            "34f5429239508138",
            "d07dea014d2dd68a",
            "f62828b434e3951b",
            "ea72bb742b3422f7",
            "0780657340cd75cc",
            "ae08f365b6a639d5",
            "16f7228e721581da",
            "35900806dc5fb044",
            "987af1e78ba9a7d1",
            "96189c0a78b84915"
        ],
        "x": 43,
        "y": 1299,
        "w": 1383,
        "h": 142
    },
    {
        "id": "b75a55c2aaa3b2b6",
        "type": "group",
        "z": "7eba58462314a0d7",
        "g": "09da833fe1650dca",
        "name": "Trame \"data\"",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#addb7b",
            "fill-opacity": "0.24"
        },
        "nodes": [
            "bc098ac8e7c2a80e",
            "e207f8c07a156191",
            "ace79b04ef5d3953",
            "b8c6447a9aadb290",
            "6ac6b1debaf96f4e",
            "e3768062bfabfaf0",
            "2773a8c67764f19a",
            "01565a6abef1f0a8",
            "62299fe8aa268603"
        ],
        "x": 74,
        "y": 1159,
        "w": 792,
        "h": 162
    },
    {
        "id": "a1697c874f4c5e2d",
        "type": "group",
        "z": "7eba58462314a0d7",
        "g": "09da833fe1650dca",
        "name": "Trame \"setup\"",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#ffbfbf",
            "fill-opacity": "0.22"
        },
        "nodes": [
            "d0b96287555baddd",
            "5379d0376efbcee9",
            "a4be995f90fc779c",
            "6ca68da351cc699c",
            "4716f48d98903bbc",
            "13e4f2a13df6fe21",
            "34aa954d066715d4",
            "aa3df0b5914b5eef",
            "d40d5fc3b0703a4d"
        ],
        "x": 74,
        "y": 939,
        "w": 952,
        "h": 162
    },
    {
        "id": "c7bb4746ce710cb1",
        "type": "group",
        "z": "7eba58462314a0d7",
        "g": "09da833fe1650dca",
        "name": "",
        "style": {
            "stroke": "#0070c0",
            "stroke-opacity": "0.44",
            "label": true,
            "fill": "#bfdbef",
            "fill-opacity": "0.15"
        },
        "nodes": [
            "74c53c8fdd7c6f6e",
            "1bb4998cb85dda4e",
            "a65a870d600bb230",
            "88b164ac7026be0e",
            "40053a1d91143e21",
            "06b6d386a10741c2",
            "9bf8da3dfdb70216",
            "eb4d973c278afdbc",
            "326f26989b977e21",
            "c467a4170735f112"
        ],
        "x": 74,
        "y": 719,
        "w": 892,
        "h": 182
    },
    {
        "id": "e17a26b0d2bf5039",
        "type": "group",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Trame 4 - Alarmes BMS",
        "style": {
            "stroke": "#ffff00",
            "fill": "#ffff7f",
            "label": true,
            "color": "#000000",
            "fill-opacity": "0.2"
        },
        "nodes": [
            "311d7af5080d4a35",
            "5fc29293a4e477ba",
            "785684768df719de",
            "88ab86576ce40ea4",
            "b1a321c3617b6aea",
            "9007859fb0b17098",
            "9ace53705bb161cf",
            "aebbfae197c3bc9f",
            "6b90f1e389dcec6b",
            "a2d4dd9068a4e071",
            "558093e71cc2db1c"
        ],
        "x": 44,
        "y": 1679,
        "w": 1082,
        "h": 182
    },
    {
        "id": "dd313e0f9fd4ef67",
        "type": "group",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "6152557feb0eac9a",
            "6957819b1dec75c3"
        ],
        "x": 784,
        "y": 999,
        "w": 282,
        "h": 82
    },
    {
        "id": "9e766385cf7c92f6",
        "type": "group",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "2621a947da028681",
            "300c67230e4e510a",
            "c516cfa766ac29a1",
            "7bd0459073759ca1",
            "b17bb5bd16c1be78",
            "fd734524924bf8a8",
            "95b5286db50cb893",
            "5dff82f5facf29e8"
        ],
        "x": 44,
        "y": 919,
        "w": 652,
        "h": 164.5
    },
    {
        "id": "6e1abcbcc6ebb714",
        "type": "serial-port",
        "name": "JKBMS-RS485-Fake",
        "serialport": "/dev/JKBMS-Fake",
        "serialbaud": "115200",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "100",
        "bin": "bin",
        "out": "interbyte",
        "addchar": "",
        "responsetimeout": "500"
    },
    {
        "id": "56f7b2737cce493b",
        "type": "mqtt-broker",
        "name": "",
        "broker": "core-mosquitto.local.hass.io",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "346118cfe13b92d2",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-node-serialport": "2.0.3",
            "@flowfuse/node-red-dashboard": "1.30.0",
            "node-red-contrib-os": "0.2.1",
            "node-red-contrib-buffer-parser": "3.2.2",
            "node-red-contrib-tcp-client2": "1.1.3"
        }
    },
    {
        "id": "477d6a6e29555062",
        "type": "ui-base",
        "name": "Setup BMS 1",
        "path": "/dashboard",
        "appIcon": "",
        "includeClientData": true,
        "acceptsClientConfig": [
            "ui-notification",
            "ui-control"
        ],
        "showPathInSidebar": true,
        "headerContent": "page",
        "navigationStyle": "default",
        "titleBarStyle": "default",
        "showReconnectNotification": true,
        "notificationDisplayTime": 5,
        "showDisconnectNotification": true,
        "allowInstall": true
    },
    {
        "id": "7f42c22c3ff64d85",
        "type": "ui-theme",
        "name": "JLM",
        "colors": {
            "surface": "#5431fb",
            "primary": "#0094ce",
            "bgPage": "#c0c0c0",
            "groupBg": "#eaeaea",
            "groupOutline": "#0000ff"
        },
        "sizes": {
            "density": "default",
            "pagePadding": "12px",
            "groupGap": "12px",
            "groupBorderRadius": "8px",
            "widgetGap": "12px"
        }
    },
    {
        "id": "page_bms1",
        "type": "ui-page",
        "name": "Live BMS 1",
        "ui": "477d6a6e29555062",
        "path": "/bms1",
        "icon": "pulse",
        "layout": "grid",
        "theme": "7f42c22c3ff64d85",
        "breakpoints": [
            {
                "name": "Default",
                "px": "0",
                "cols": "3"
            },
            {
                "name": "Tablet",
                "px": "576",
                "cols": "6"
            },
            {
                "name": "Small Desktop",
                "px": "768",
                "cols": "9"
            },
            {
                "name": "Desktop",
                "px": "1024",
                "cols": "12"
            }
        ],
        "order": 1,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "group_bms1",
        "type": "ui-group",
        "name": "Live BMS 1",
        "page": "page_bms1",
        "width": "12",
        "height": "1",
        "order": 1,
        "showTitle": false,
        "className": "",
        "visible": "true",
        "disabled": "false",
        "groupType": "default"
    },
    {
        "id": "page_static",
        "type": "ui-page",
        "name": "Infos BMS 1",
        "ui": "477d6a6e29555062",
        "path": "/infos-bms",
        "icon": "database",
        "layout": "grid",
        "theme": "7f42c22c3ff64d85",
        "breakpoints": [
            {
                "name": "Default",
                "px": "0",
                "cols": "3"
            },
            {
                "name": "Tablet",
                "px": "576",
                "cols": "6"
            },
            {
                "name": "Small Desktop",
                "px": "768",
                "cols": "9"
            },
            {
                "name": "Desktop",
                "px": "1024",
                "cols": "12"
            }
        ],
        "order": 3,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "group_static",
        "type": "ui-group",
        "name": "Infos BMS 1",
        "page": "page_static",
        "width": "12",
        "height": "1",
        "order": 1,
        "showTitle": false,
        "className": "",
        "visible": true,
        "disabled": "false",
        "groupType": "default"
    },
    {
        "id": "a076c0a708cffec2",
        "type": "ui-page",
        "name": "Setup BMS 1",
        "ui": "477d6a6e29555062",
        "path": "/setup1",
        "icon": "cog",
        "layout": "grid",
        "theme": "7f42c22c3ff64d85",
        "breakpoints": [
            {
                "name": "Default",
                "px": "0",
                "cols": "3"
            },
            {
                "name": "Tablet",
                "px": "576",
                "cols": "6"
            },
            {
                "name": "Small Desktop",
                "px": "768",
                "cols": "9"
            },
            {
                "name": "Desktop",
                "px": "1024",
                "cols": "12"
            }
        ],
        "order": 2,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "6af349ba04c1ad8a",
        "type": "ui-group",
        "name": "Setup BMS",
        "page": "a076c0a708cffec2",
        "width": "12",
        "height": "1",
        "order": 1,
        "showTitle": false,
        "className": "",
        "visible": "true",
        "disabled": "false",
        "groupType": "default"
    },
    {
        "id": "bd32d7ad2e41fd6b",
        "type": "inject",
        "z": "6fc9763d4087338c",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "url",
                "v": "https://domosimple.eu/valide/check_license.php?license_key=LIC-675AA47154DF52.6175956",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 100,
        "y": 100,
        "wires": [
            [
                "baef5c9129331285"
            ]
        ]
    },
    {
        "id": "1ce6a7eabb31a0e3",
        "type": "function",
        "z": "6fc9763d4087338c",
        "name": "function 99",
        "func": "// Vérifier si le payload est une chaîne JSON\ntry {\n    // Tenter de parser la chaîne JSON dans le payload\n    var jsonData = JSON.parse(msg.payload);\n\n    // Maintenant vous pouvez accéder aux propriétés de jsonData\n    msg.payload = {\n        status: jsonData.status,\n        expiration: jsonData.expiration\n    };\n\n} catch (e) {\n    // Si le parsing échoue, afficher une erreur et conserver l'ancienne valeur\n    node.error(\"Erreur de parsing JSON : \" + e.message);\n\n    // En cas d'erreur de parsing, récupérer la date d'expiration depuis les paramètres globaux\n    msg.payload = {\n        expiration: global.get('parametre.li.expiration'),\n        erreur: \"Problème serveur, mais licence toujours valide\",\n        status: true // Le statut reste à true, indiquant que la licence existe toujours\n    };\n}\n\n// Fonction pour vérifier la date d'expiration avec le serveur\nif (msg.payload.status === \"true\" || msg.payload.status === true) {\n    // Licence existe, vérifier la date d'expiration\n    const expirationDate = new Date(msg.payload.expiration); // Convertir la date d'expiration au format Date\n    const currentDate = new Date();\n\n    // Comparer les deux dates\n    if (expirationDate < currentDate) {\n        msg.payload.status = false;  // Licence expirée\n        global.set('parametre.li.active', false); // Mettre à jour le statut dans les paramètres globaux\n        global.set('parametre.li.expiration', expirationDate.toISOString()); // Enregistrer la date d'expiration\n        msg.erreur = \"License expirer\"\n        node.send(msg);\n    } else {\n        msg.payload.status = true; // Licence valide\n        global.set('parametre.li.active', true); // Mettre à jour le statut dans les paramètres globaux\n        global.set('parametre.li.expiration', expirationDate.toISOString()); // Enregistrer la date d'expiration\n    }\n} else {\n    // Licence n'existe pas ou problème de serveur\n    msg.payload.status = false; // Licence n'existe pas\n    global.set('parametre.li.active', false); // Mettre à jour le statut dans les paramètres globaux\n    global.set('parametre.li.expiration', null); // Pas de date d'expiration car la licence n'existe pas\n    msg.erreur = \"Licence n'existe pas\"\n    node.send(msg);\n}\n\n\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "a7bf12e890b893de",
        "type": "http request",
        "z": "6fc9763d4087338c",
        "name": "",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 550,
        "y": 100,
        "wires": [
            [
                "1ce6a7eabb31a0e3"
            ]
        ]
    },
    {
        "id": "baef5c9129331285",
        "type": "function",
        "z": "6fc9763d4087338c",
        "name": "function 100",
        "func": "msg.license = global.get(\"parametre.li.num\");\nmsg.url = \"https://domosimple.eu/valide/valide.php?license_key=\" + msg.license\nmsg.headers = {\n    'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',\n    'Pragma': 'no-cache',\n    'Expires': '0'\n};\nreturn msg",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 100,
        "wires": [
            [
                "a7bf12e890b893de"
            ]
        ]
    },
    {
        "id": "438bd283fc7ed79f",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "This software is the property of JLM . It is subject to intellectual property and copyright laws.",
        "info": "",
        "x": 330,
        "y": 134,
        "wires": []
    },
    {
        "id": "25c51ee819816528",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "copyright ©JLM 2025 - 2026",
        "info": "",
        "x": 140,
        "y": 74,
        "wires": []
    },
    {
        "id": "ff1ece7fe3612315",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "Only JLM has the right to modify all or part of this software.",
        "info": "",
        "x": 230,
        "y": 260,
        "wires": []
    },
    {
        "id": "2c25611ae5eaf661",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "It has been designed to manage JK-KONG BMS type: PBxA1xS1xP",
        "info": "",
        "x": 260,
        "y": 200,
        "wires": []
    },
    {
        "id": "e57773e891517763",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "Do not transmit, copy or modify this software without the written consent of its authors.",
        "info": "",
        "x": 320,
        "y": 320,
        "wires": []
    },
    {
        "id": "1886fc8967eaf339",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "According to article L335-3 of the French Intellectual Property Code, “infringement of one of the rights of the author of a software program as defined in article L122-6” constitutes an offence of counterfeiting.",
        "info": "",
        "x": 690,
        "y": 380,
        "wires": []
    },
    {
        "id": "212b75fb3d14df62",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "Any infringement of a software author's rights can therefore be qualified as counterfeiting.",
        "info": "",
        "x": 330,
        "y": 440,
        "wires": []
    },
    {
        "id": "00678a50f9f3ef9c",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "Setup USB Port",
        "func": "// récupère le port série à utiliser\n    msg.payload = {\n    \"serialport\": global.get(\"path\"),\n    \"serialbaud\": 115800,\n    \"databits\": 8,\n    \"parity\": \"none\",\n    \"stopbits\": 1,\n    \"enabled\": true\n    }\n\n    node.send(msg)",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 400,
        "wires": [
            [
                "df5482d67ec293f9"
            ]
        ]
    },
    {
        "id": "0c9baa364697bbfe",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1.5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 400,
        "wires": [
            [
                "49c92598895378e1"
            ]
        ]
    },
    {
        "id": "df5482d67ec293f9",
        "type": "serial control",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "JKBMS-RS485-Fake",
        "serial": "6e1abcbcc6ebb714",
        "x": 730,
        "y": 400,
        "wires": [
            [
                "36ac99672d282e93"
            ]
        ]
    },
    {
        "id": "36ac99672d282e93",
        "type": "debug",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "Serial Control",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 400,
        "wires": []
    },
    {
        "id": "3fba971ea0547c66",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "d9178a09ade71024",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 60,
        "wires": [
            [
                "3ecb0dcd9663050d"
            ]
        ]
    },
    {
        "id": "3ecb0dcd9663050d",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "d9178a09ade71024",
        "name": "initialisation slaveAddress-Trame-1-2-3",
        "rules": [
            {
                "t": "set",
                "p": "slaveAddress-Trame1",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "slaveAddress-Trame2",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "slaveAddress-Trame3",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "slaveAddress-setup",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "gateway_ip",
                "pt": "global",
                "to": "192.168.1.238",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "gateway_port",
                "pt": "global",
                "to": "8887",
                "tot": "num"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 400,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "80a0031e2a8dbfbc",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "disconnect",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "action",
                "v": "disconnect",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 520,
        "wires": [
            [
                "4e25b5fa6500606e"
            ]
        ]
    },
    {
        "id": "355fec0a2e1aaf7a",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "connect",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 580,
        "wires": [
            [
                "b82078ca27edc9db"
            ]
        ]
    },
    {
        "id": "b82078ca27edc9db",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "Défiition du Broker",
        "func": "msg.action = \"connect\";\nmsg.broker = '{\"broker\":\"' + global.get(\"mqttadresse\")+'\",'\n    + '\"port\":\"' + global.get(\"mqttport\")+'\",'\n    + '\"username\":\"' + global.get(\"mqttuser\")+'\",'\n    + '\"password\":\"' + global.get(\"mqttpass\")+'\"'\n    +'}';\nreturn msg\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 580,
        "wires": [
            [
                "58adbc8abf20aab0"
            ]
        ]
    },
    {
        "id": "58adbc8abf20aab0",
        "type": "json",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "",
        "property": "broker",
        "action": "",
        "pretty": false,
        "x": 490,
        "y": 580,
        "wires": [
            [
                "4e25b5fa6500606e",
                "0c319b0244658cad",
                "468d5c1a95681d8d"
            ]
        ]
    },
    {
        "id": "4e25b5fa6500606e",
        "type": "mqtt out",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "MQTT Broker",
        "topic": "",
        "qos": "1",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 680,
        "y": 520,
        "wires": []
    },
    {
        "id": "0c319b0244658cad",
        "type": "debug",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "debug 23",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 580,
        "wires": []
    },
    {
        "id": "12543920bca0a8e5",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 220,
        "wires": [
            [
                "5c144e0e135713c7"
            ]
        ]
    },
    {
        "id": "5c144e0e135713c7",
        "type": "file in",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "",
        "filename": "/data/options.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 350,
        "y": 220,
        "wires": [
            [
                "9db46980e482d881"
            ]
        ]
    },
    {
        "id": "9db46980e482d881",
        "type": "json",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 510,
        "y": 220,
        "wires": [
            [
                "b122ec506872171a",
                "416789eaf381cb09"
            ]
        ]
    },
    {
        "id": "2682276da62a0840",
        "type": "debug",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "debug 97",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 220,
        "wires": []
    },
    {
        "id": "0ec51b6fd8d48038",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1020,
        "wires": [
            [
                "84db6ed2a0945bdd"
            ]
        ]
    },
    {
        "id": "84db6ed2a0945bdd",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "GW true ",
        "rules": [
            {
                "t": "set",
                "p": "use_gateway",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 320,
        "y": 1020,
        "wires": [
            []
        ]
    },
    {
        "id": "a0a0d9469406c5a8",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1060,
        "wires": [
            [
                "b38da9cc0fe45944"
            ]
        ]
    },
    {
        "id": "b38da9cc0fe45944",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "GW false ",
        "rules": [
            {
                "t": "set",
                "p": "use_gateway",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 320,
        "y": 1060,
        "wires": [
            []
        ]
    },
    {
        "id": "18be8868fd9888b7",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1100,
        "wires": [
            [
                "567fe9a7f3910323"
            ]
        ]
    },
    {
        "id": "567fe9a7f3910323",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "BMS Broadcasting ? True",
        "rules": [
            {
                "t": "set",
                "p": "bms_broadcasting",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 370,
        "y": 1100,
        "wires": [
            []
        ]
    },
    {
        "id": "32d98207bb37887d",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1140,
        "wires": [
            [
                "9d3d9cd9d0aaf884"
            ]
        ]
    },
    {
        "id": "9d3d9cd9d0aaf884",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "BMS Broadcasting ? False",
        "rules": [
            {
                "t": "set",
                "p": "bms_broadcasting",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 380,
        "y": 1140,
        "wires": [
            []
        ]
    },
    {
        "id": "2f1946e570f89af5",
        "type": "file",
        "z": "b1ca67b21089b915",
        "g": "09c8d74836111377",
        "name": "",
        "filename": "/config/temp/broadcast-bms.txt",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 730,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "4b621344460ef394",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "09c8d74836111377",
        "name": "debug en hexa",
        "func": "// Vérifie que le payload est un Buffer\nif (Buffer.isBuffer(msg.payload)) {\n    // Convertit chaque octet en hexadécimal sur 2 chiffres\n    msg.payload = msg.payload\n        .toString('hex')                // Convertit tout le buffer en une chaîne hexadécimale continue\n        .match(/.{1,2}/g)               // Coupe la chaîne tous les 2 caractères\n        .join(' ') + '\\n';              // Ajoute un espace entre chaque octet et un retour à la ligne\n} else if (Array.isArray(msg.payload)) {\n    // Si c'est un tableau, on le traite aussi\n    msg.payload = msg.payload\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join(' ') + '\\n';\n} else {\n    // Sinon, on ne fait rien ou on peut lever une erreur\n    msg.payload = 'Payload non reconnu\\n';\n}\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 682.2000122070312,
        "y": 1130.199951171875,
        "wires": [
            [
                "2f1946e570f89af5"
            ]
        ]
    },
    {
        "id": "66ce0bd5261eb149",
        "type": "mqtt out",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "Onduleur",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 680,
        "y": 620,
        "wires": []
    },
    {
        "id": "63efeee1a97e3bb9",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "Publie \"Online\"",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 620,
        "wires": [
            [
                "468d5c1a95681d8d"
            ]
        ]
    },
    {
        "id": "323bc1fdf8eb4b0e",
        "type": "delay",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "",
        "pauseType": "delay",
        "timeout": "10",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 500,
        "y": 620,
        "wires": [
            [
                "66ce0bd5261eb149"
            ]
        ]
    },
    {
        "id": "468d5c1a95681d8d",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "Informe \"Online\"",
        "func": "msg.payload = \"Online\";\nmsg.topic = \"JK-BMS-RS485-CAN-module\";\nmsg.action = \"\";\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 620,
        "wires": [
            [
                "323bc1fdf8eb4b0e"
            ]
        ]
    },
    {
        "id": "ea424593a0b6533a",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1180,
        "wires": [
            [
                "4a6179de378fa7c5"
            ]
        ]
    },
    {
        "id": "4a6179de378fa7c5",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "communication_debug true ",
        "rules": [
            {
                "t": "set",
                "p": "communication_debug",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 380,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "6fa5d0c215b7e641",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1220,
        "wires": [
            [
                "8bcf0e0b17b0565f"
            ]
        ]
    },
    {
        "id": "8bcf0e0b17b0565f",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "communication_debug false ",
        "rules": [
            {
                "t": "set",
                "p": "communication_debug",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 380,
        "y": 1220,
        "wires": [
            []
        ]
    },
    {
        "id": "b122ec506872171a",
        "type": "debug",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "debug 4",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 260,
        "wires": []
    },
    {
        "id": "416789eaf381cb09",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "traitement des variables",
        "func": "// Récupération des données du payload\nconst data = msg.payload;\n\n// Fonction pour traiter les champs contenant \":\"\nfunction processAddressPortFields(data) {\n    const processedData = {...data}; // Copie de l'objet original\n    \n    // Liste des champs à traiter (ceux qui peuvent contenir adresse:port)\n    const fieldsToProcess = [\n        { field: 'gateway_ip_port', addressField: 'gateway_ip', portField: 'gateway_port' },\n        { field: 'mqttadresse_port', addressField: 'mqttadresse', portField: 'mqttport' },\n        { field: 'cloud_broker_adress_port', addressField: 'cloud_broker_adress', portField: 'cloud_broker_port' }\n    ];\n    \n    fieldsToProcess.forEach(config => {\n        if (processedData[config.field] && typeof processedData[config.field] === 'string') {\n            const value = processedData[config.field];\n            \n            // Vérifier si le champ contient \":\"\n            if (value.includes(':')) {\n                const lastColonIndex = value.lastIndexOf(':'); // Utilise le dernier \":\" pour gérer les IPv6\n                const address = value.substring(0, lastColonIndex);\n                const port = value.substring(lastColonIndex + 1);\n                \n                // Ajouter les champs séparés\n                processedData[config.addressField] = address;\n                processedData[config.portField] = parseInt(port, 10);\n                \n                node.log(`Champ '${config.field}' traité: ${address}:${port}`);\n            }\n            \n            // Supprimer le champ original avec \"_port\" \n            delete processedData[config.field];\n        }\n    });\n    \n    return processedData;\n}\n\n// Extraction et stockage des variables globales\ntry {\n    // Traitement préalable des champs avec \":\"\n    const processedData = processAddressPortFields(data);\n    \n    // Configuration JK-BMS principale\n    if (processedData.jkbms_path) {\n        global.set(\"path\", processedData.jkbms_path);\n        node.log(\"Variable globale 'path' = \" + processedData.jkbms_path);\n    }\n    \n    if (processedData.jkbms_count) {\n        global.set(\"nb_jkbms\", processedData.jkbms_count);\n        node.log(\"Variable globale 'nb_jkbms' = \" + processedData.jkbms_count);\n    }\n    \n    // Configuration Gateway\n    if (processedData.use_gateway !== undefined) {\n        global.set(\"use_gateway\", processedData.use_gateway);\n        node.log(\"Variable globale 'use_gateway' = \" + processedData.use_gateway);\n    }\n    \n    if (processedData.gateway_ip !== undefined) {\n        global.set(\"gateway_ip\", processedData.gateway_ip);\n        node.log(\"Variable globale 'gateway_ip' = \" + processedData.gateway_ip);\n    }\n    \n    if (processedData.gateway_port !== undefined) {\n        global.set(\"gateway_port\", processedData.gateway_port);\n        node.log(\"Variable globale 'gateway_port' = \" + processedData.gateway_port);\n    }\n    \n    if (processedData.communication_debug !== undefined) {\n        global.set(\"communication_debug\", processedData.communication_debug);\n        node.log(\"Variable globale 'communication_debug' = \" + processedData.communication_debug);\n    }\n     \n    if (processedData.bms_broadcasting !== undefined) {\n        global.set(\"bms_broadcasting\", processedData.bms_broadcasting);\n        node.log(\"Variable globale 'bms_broadcasting' = \" + processedData.bms_broadcasting);\n    }\n   \n    if (processedData.CAN_bus_usage !== undefined) {\n        global.set(\"CAN_bus_usage\", processedData.CAN_bus_usage);\n        node.log(\"Variable globale 'CAN_bus_usage' = \" + processedData.CAN_bus_usage);\n    }\n\n    // Paramètres MQTT\n    if (processedData.mqttadresse) {\n        global.set(\"mqttadresse\", processedData.mqttadresse);\n        node.log(\"Variable globale 'mqttadresse' = \" + processedData.mqttadresse);\n    }\n    \n    if (processedData.mqttport) {\n        global.set(\"mqttport\", processedData.mqttport);\n        node.log(\"Variable globale 'mqttport' = \" + processedData.mqttport);\n    }\n    \n    if (processedData.mqttuser) {\n        global.set(\"mqttuser\", processedData.mqttuser);\n        node.log(\"Variable globale 'mqttuser' = \" + processedData.mqttuser);\n    }\n    \n    if (processedData.mqttpass) {\n        global.set(\"mqttpass\", processedData.mqttpass);\n        node.log(\"Variable globale 'mqttpass' = •••••••••\");\n    }\n\n    if (processedData.Send_bip !== undefined) {\n        global.set(\"Send_bip\", processedData.Send_bip);\n        node.log(\"Variable globale 'Send_bip' = \" + processedData.Send_bip);\n    }\n\n    // Message de confirmation\n    msg.payload = {\n        status: \"success\",\n        message: \"Variables globales créées avec succès\",\n        variables: {\n            path: global.get(\"path\"),\n            nb_jkbms: global.get(\"nb_jkbms\"),\n            use_gateway: global.get(\"use_gateway\"),\n            gateway_ip: global.get(\"gateway_ip\"),\n            gateway_port: global.get(\"gateway_port\"),\n            communication_debug: global.get(\"communication_debug\"),\n            bms_broadcasting: global.get(\"bms_broadcasting\"),\n            mqttadresse: global.get(\"mqttadresse\"),\n            mqttport: global.get(\"mqttport\"),\n            mqttuser: global.get(\"mqttuser\"),\n            mqttpass: global.get(\"mqttpass\"),\n            CAN_bus_usage: global.get(\"CAN_bus_usage\"),\n            Send_bip: global.get(\"Send_bip\")\n        },\n        processedData: processedData // Pour debugging\n    };\n\n} catch (error) {\n    node.error(\"Erreur lors de la création des variables globales: \" + error.message);\n    msg.payload = {\n        status: \"error\",\n        message: error.message\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 220,
        "wires": [
            [
                "2682276da62a0840"
            ]
        ]
    },
    {
        "id": "49c92598895378e1",
        "type": "switch",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 320,
        "y": 400,
        "wires": [
            [],
            [
                "00678a50f9f3ef9c"
            ]
        ],
        "outputLabels": [
            "Ip Gateway",
            "Serial Port"
        ]
    },
    {
        "id": "691f43464b1625d9",
        "type": "NetworkIntf",
        "z": "b1ca67b21089b915",
        "g": "0bab67838083522a",
        "name": "",
        "x": 310,
        "y": 740,
        "wires": [
            [
                "7060e96cd73705af"
            ]
        ]
    },
    {
        "id": "e05d7ff558a4dbae",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "0bab67838083522a",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "7",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 740,
        "wires": [
            [
                "691f43464b1625d9"
            ]
        ]
    },
    {
        "id": "7060e96cd73705af",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "0bab67838083522a",
        "name": "URL standalone",
        "func": "var IP = msg.payload.networkInterfaces.enp2s0[0].address\n// Pour debug, affichons la valeur URL Dashboard Node Red\nnode.warn(`⏩ Dashboard URL for Standalone version: http://${IP}:1891/endpoint/dashboard/`);\nnode.warn(`⏩ Please do not use with HAOS, only in standalone mode (executable for Windows or Linux)`);\nnode.warn(`⏩ If you still wish to use it in HAOS, use the \"iFrame\" card with the above address`);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "d84c3f32b5bee13a",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Live Trame 3   -  #5664 - 0x1620",
        "func": "// Création de la trame Modbus pour registre 5664\nlet currentAddress = global.get(\"slaveAddress-Trame3\") || 1; // Valeur par défaut : 1\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame3\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x10;\nconst registerHigh = 0x16;\nconst registerLow = 0x20;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\nconst byteCount = 0x02;\nconst valueHigh = 0x00;\nconst valueLow = 0x00;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow,\n    byteCount,\n    valueHigh,\n    valueLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-3-dynamiques\"\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 700,
        "wires": [
            [
                "a632bb3545ad81d5",
                "3782b34f573f61fe"
            ]
        ]
    },
    {
        "id": "1430199873abea94",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Fixes Trame 1  -  #5660 - 0x161C",
        "func": "// Création de la trame Modbus pour registre 5664\nlet currentAddress = global.get(\"slaveAddress-Trame1\") || 1; // Valeur par défaut : 1\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x10;\nconst registerHigh = 0x16;\nconst registerLow = 0x1C;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\nconst byteCount = 0x02;\nconst valueHigh = 0x00;\nconst valueLow = 0x00;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow,\n    byteCount,\n    valueHigh,\n    valueLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-1-statiques\"\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 560,
        "wires": [
            [
                "a632bb3545ad81d5"
            ]
        ]
    },
    {
        "id": "19e4f82b41b8041a",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "Serial-In",
        "links": [
            "389031f7d149d0e4",
            "6542c8ba28167fbf"
        ],
        "x": 95,
        "y": 420,
        "wires": [
            [
                "29aa81cab8e98225"
            ]
        ]
    },
    {
        "id": "9df6cb4f228ce42d",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Setup Trame 2  -  #5662 - 0x1622",
        "func": "// Création de la trame Modbus pour registre 5662\nlet currentAddress = global.get(\"slaveAddress-Trame2\") || 1; // Valeur par défaut : 1\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame2\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x10;\nconst registerHigh = 0x16;\nconst registerLow = 0x1E;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\nconst byteCount = 0x02;\nconst valueHigh = 0x00;\nconst valueLow = 0x00;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow,\n    byteCount,\n    valueHigh,\n    valueLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-2-setup\"\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 620,
        "wires": [
            [
                "a632bb3545ad81d5"
            ]
        ]
    },
    {
        "id": "a6b1b65a3e856d8f",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Trame 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 188,
        "y": 1540,
        "wires": []
    },
    {
        "id": "867fca3b9f77ce27",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "setup",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 369,
        "y": 1340,
        "wires": []
    },
    {
        "id": "2621a947da028681",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "9e766385cf7c92f6",
        "name": "link in 3",
        "links": [
            "9fb62a629d09612b",
            "03d54d1f353534ca"
        ],
        "x": 85,
        "y": 1020,
        "wires": [
            [
                "300c67230e4e510a",
                "95b5286db50cb893"
            ]
        ]
    },
    {
        "id": "3987f9e640e885a6",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Trame 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 189,
        "y": 1340,
        "wires": []
    },
    {
        "id": "b2d928a2b649fe63",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Trame 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 200,
        "y": 1160,
        "wires": []
    },
    {
        "id": "bbe7f5ddcea331a9",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "statics",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 350,
        "y": 1160,
        "wires": []
    },
    {
        "id": "264d6f5686cf22f1",
        "type": "buffer-parser",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Trame 1",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "ascii",
                "name": "BMS_A",
                "offset": 6,
                "length": 13,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "FW_A",
                "offset": 22,
                "length": 3,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "SW_N",
                "offset": 30,
                "length": 5,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Uptime_S",
                "offset": 38,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Power_count_N",
                "offset": 42,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "SerialNb_N",
                "offset": 46,
                "length": 13,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Password1_A",
                "offset": 62,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Manufacturing_date_N",
                "offset": 78,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Brand_A",
                "offset": 102,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Password2_A",
                "offset": 118,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "UART1_protocol_number_N",
                "offset": 184,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "CAN_protocol_number_N",
                "offset": 185,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "LCD_buzzer_trigger_N",
                "offset": 234,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "LCD_buzzer_trigger_value_N",
                "offset": 238,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "LCD_buzzer_release_value_N",
                "offset": 242,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "Request_Charge_voltage_Time_H",
                "offset": 266,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "Request_Float_voltage_Time_H",
                "offset": 267,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 420,
        "y": 1200,
        "wires": [
            [
                "bbe7f5ddcea331a9",
                "1c51761e84ee5bb2",
                "dab766c54a57452d",
                "c054e6c82bc4bb0a",
                "32f3c0d652235f1c"
            ]
        ]
    },
    {
        "id": "5e23433b1e088edf",
        "type": "serial request",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "JKBMS-RS485",
        "serial": "6e1abcbcc6ebb714",
        "x": 390,
        "y": 420,
        "wires": [
            [
                "47ab0322cedc3c22",
                "9fb62a629d09612b",
                "54c93e67707946a8"
            ]
        ]
    },
    {
        "id": "300c67230e4e510a",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "9e766385cf7c92f6",
        "name": "Trame 1-2-3-Alarmes-Autres",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Trame-1-statiques",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Trame-2-setup",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Trame-3-dynamiques",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Trame-Alarmes-BMS",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 5,
        "x": 260,
        "y": 1020,
        "wires": [
            [
                "b17bb5bd16c1be78"
            ],
            [
                "7bd0459073759ca1"
            ],
            [
                "c516cfa766ac29a1"
            ],
            [
                "5dff82f5facf29e8"
            ],
            [
                "fd734524924bf8a8"
            ]
        ]
    },
    {
        "id": "9fb62a629d09612b",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "Serial Out",
        "mode": "link",
        "links": [
            "2621a947da028681"
        ],
        "x": 525,
        "y": 420,
        "wires": []
    },
    {
        "id": "47ab0322cedc3c22",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "Modbus Out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 380,
        "y": 380,
        "wires": []
    },
    {
        "id": "6152557feb0eac9a",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "dd313e0f9fd4ef67",
        "name": "Autres trame",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 950,
        "y": 1040,
        "wires": []
    },
    {
        "id": "4c893435cad6711e",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Vérifie Trame 3",
        "func": "const expectedHeader = [0x55, 0xAA, 0xEB, 0x90, 0x02];\nconst expectedLength = 308;\n\n// Vérifie si le buffer commence par la séquence attendue et fait la bonne longueur\nfunction checkBuffer(buffer) {\n    // Vérifie d'abord la longueur totale\n    if (buffer.length !== expectedLength) return false;\n\n    // Vérifie ensuite l'en-tête\n    if (buffer.length < expectedHeader.length) return false;\n\n    for (let i = 0; i < expectedHeader.length; i++) {\n        if (buffer[i] !== expectedHeader[i]) return false;\n    }\n    return true;\n}\n\nif (checkBuffer(msg.payload)) {\n    return msg;\n} else {\n    return null; // Ne transmet pas le message si la vérification échoue\n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 208,
        "y": 1580,
        "wires": [
            [
                "c6f86ca54e23c581"
            ],
            []
        ]
    },
    {
        "id": "c516cfa766ac29a1",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "9e766385cf7c92f6",
        "name": "trame3-out",
        "mode": "link",
        "links": [
            "c0f222bb926bd319"
        ],
        "x": 535,
        "y": 1000,
        "wires": []
    },
    {
        "id": "c0f222bb926bd319",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "trame3-in",
        "links": [
            "c516cfa766ac29a1"
        ],
        "x": 83,
        "y": 1580,
        "wires": [
            [
                "4c893435cad6711e",
                "a6b1b65a3e856d8f"
            ]
        ]
    },
    {
        "id": "7bd0459073759ca1",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "9e766385cf7c92f6",
        "name": "trame2-out",
        "mode": "link",
        "links": [
            "dde116783a665a3f"
        ],
        "x": 475,
        "y": 980,
        "wires": []
    },
    {
        "id": "dde116783a665a3f",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "trame2-in",
        "links": [
            "7bd0459073759ca1"
        ],
        "x": 84,
        "y": 1360,
        "wires": [
            [
                "3987f9e640e885a6",
                "34f5429239508138"
            ]
        ]
    },
    {
        "id": "34f5429239508138",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Vérifie Trame 2",
        "func": "//const expectedHeader = [0x55, 0xAA, 0xEB, 0x90, 0x01];\nconst expectedHeader = [0x55, 0xAA, 0xEB, 0x90, 0x01];\n\n// Vérifie si le buffer commence par la séquence attendue\nfunction checkHeader(buffer) {\n    if (buffer.length < expectedHeader.length) return false;\n    \n    for (let i = 0; i < expectedHeader.length; i++) {\n        if (buffer[i] !== expectedHeader[i]) return false;\n    }\n    return true;\n}\n\nif (checkHeader(msg.payload)) {\n    return msg;\n} else {\n    return null; // Ne transmet pas le message si l'en-tête ne correspond pas\n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 209,
        "y": 1380,
        "wires": [
            [
                "d07dea014d2dd68a"
            ],
            []
        ]
    },
    {
        "id": "b17bb5bd16c1be78",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "9e766385cf7c92f6",
        "name": "trame1-out",
        "mode": "link",
        "links": [
            "7a45939101576456"
        ],
        "x": 425,
        "y": 960,
        "wires": []
    },
    {
        "id": "7a45939101576456",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "trame1-in",
        "links": [
            "b17bb5bd16c1be78"
        ],
        "x": 85,
        "y": 1200,
        "wires": [
            [
                "2492d95ecc9f328c",
                "b2d928a2b649fe63"
            ]
        ]
    },
    {
        "id": "2492d95ecc9f328c",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Vérifie Trame 1",
        "func": "const expectedHeader = [0x55, 0xAA, 0xEB, 0x90];\n\n// Vérifie si le buffer commence par la séquence attendue\nfunction checkHeader(buffer) {\n    if (buffer.length < expectedHeader.length) return false;\n    \n    for (let i = 0; i < expectedHeader.length; i++) {\n        if (buffer[i] !== expectedHeader[i]) return false;\n    }\n    return true;\n}\n\nif (checkHeader(msg.payload)) {\n    return msg;\n} else {\n    return null; // Ne transmet pas le message si l'en-tête ne correspond pas\n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 220,
        "y": 1200,
        "wires": [
            [
                "264d6f5686cf22f1"
            ],
            []
        ]
    },
    {
        "id": "60a06da8cc236522",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "data's",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 398,
        "y": 1540,
        "wires": []
    },
    {
        "id": "97a3abc79a4c67cd",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "MQTT data",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1310,
        "y": 1580,
        "wires": []
    },
    {
        "id": "d8f9f00da2e3a338",
        "type": "mqtt out",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 1160,
        "y": 1580,
        "wires": []
    },
    {
        "id": "32a6b862b301b073",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "MQTT static",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1310,
        "y": 1200,
        "wires": []
    },
    {
        "id": "cb1a7697e8293f75",
        "type": "mqtt out",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 1160,
        "y": 1200,
        "wires": []
    },
    {
        "id": "d07dea014d2dd68a",
        "type": "buffer-parser",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Trame 2",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "int32le",
                "name": "smart_sleep_voltage_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_protection_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_recovery_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_protection_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_recovery_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_trigger_voltage_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc100_voltage_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc0_voltage_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_charge_voltage_V",
                "offset": 38,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_float_voltage_V",
                "offset": 42,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_off_voltage_V",
                "offset": 46,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_charge_current_A",
                "offset": 50,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_delay_S",
                "offset": 54,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_recovery_time_S",
                "offset": 58,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_discharge_current_S",
                "offset": 62,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_delay_S",
                "offset": 66,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_recovery_time_S",
                "offset": 70,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_recovery_time_S",
                "offset": 74,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_balance_current_A",
                "offset": 78,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_T",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_recovery_T",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_T",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_recovery_T",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_T",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_recovery_T",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_T",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_recovery_T",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_count_N",
                "offset": 114,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "charging_switch_B",
                "offset": 118,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "discharging_switch_B",
                "offset": 122,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "balance_switch_B",
                "offset": 126,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "total_battery_capacity_Ah",
                "offset": 130,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_delay_S",
                "offset": 134,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_starting_voltage_V",
                "offset": 138,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Connexion_wire_resistance_1_R",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Device_address_N",
                "offset": 270,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "display_always_on_switch_B",
                "offset": 282,
                "length": 2,
                "offsetbit": 4,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "smart_sleep_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 7,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "disable_pcl_module_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 8,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "timed_stored_data_switch_B",
                "offset": 283,
                "length": 1,
                "offsetbit": 1,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "0x1114",
                "offset": 282,
                "length": 1,
                "offsetbit": 2,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 379,
        "y": 1380,
        "wires": [
            [
                "f62828b434e3951b",
                "867fca3b9f77ce27",
                "ae08f365b6a639d5",
                "96189c0a78b84915"
            ]
        ]
    },
    {
        "id": "f62828b434e3951b",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Trame \"setup\" to MQTT",
        "func": "// Récupération de l'ID d'esclave\nconst slaveId = global.get(\"slaveAddress-Trame2\") || 0x01;\nconst slaveIdNumber = typeof slaveId === 'string' ? parseInt(slaveId, 16) : slaveId;\n\nconst discoveryKey = `discoverySent_SETUP_BMS_${slaveIdNumber}`;\nconst discoveryAlreadySent = flow.get(discoveryKey) || false;\n\n// ------------------------------------------------------------------\n// Constantes\nconst baseTopic = \"BMS_\" + slaveIdNumber;\nconst discoveryPrefix = \"homeassistant\";\nconst deviceName = \"BMS_\" + slaveIdNumber;\nconst deviceID = \"BMS_\" + slaveIdNumber + \"_device\";\n\nconst customBounds = {\n    max_charge_current_A: { min: 0, max: 600, step: 0.1, unit: \"A\" },\n    max_discharge_current_S: { min: 0, max: 600, step: 0.1, unit: \"A\" },\n    max_balance_current_A: { min: 0, max: 10, step: 0.1, unit: \"A\" },\n    total_battery_capacity_Ah: { min: 5, max: 2000, step: 1, unit: \"Ah\" },\n    short_circuit_protection_delay_S: { min: 0, max: 5000, step: 1, unit: \"s\" },\n    charge_overcurrent_protection_delay_S: { min: 2, max: 600, step: 1, unit: \"s\" },\n    discharge_overcurrent_protection_delay_S: { min: 2, max: 600, step: 1, unit: \"s\" },\n    charge_overcurrent_protection_recovery_time_S: { min: 2, max: 3600, step: 1, unit: \"s\" },\n    discharge_overcurrent_protection_recovery_time_S: { min: 2, max: 3600, step: 1, unit: \"s\" },\n    short_circuit_protection_recovery_time_S: { min: 2, max: 600, step: 1, unit: \"s\" },\n    smart_sleep_voltage_V: { min: 0, max: 5, step: 0.01, unit: \"V\" },\n    cell_voltage_undervoltage_protection_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_voltage_undervoltage_recovery_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_voltage_overvoltage_protection_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_voltage_overvoltage_recovery_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    balance_trigger_voltage_V: { min: 0.003, max: 1, step: 0.001, unit: \"V\" },\n    cell_soc100_voltage_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_soc0_voltage_V: { min: 1, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_request_charge_voltage_V: { min: 1.2, max: 5, step: 0.01, unit: \"V\" },\n    cell_request_float_voltage_V: { min: 1.2, max: 5, step: 0.01, unit: \"V\" },\n    power_off_voltage_V: { min: 1.2, max: 4.5, step: 0.01, unit: \"V\" },\n    balance_starting_voltage_V: { min: 1.2, max: 4.25, step: 0.01, unit: \"V\" },\n    charge_overtemperature_protection_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n    charge_overtemperature_protection_recovery_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n    discharge_overtemperature_protection_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n    discharge_overtemperature_protection_recovery_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n    charge_undertemperature_protection_T: { min: -40, max: 50, step: 0.5, unit: \"°C\" },\n    charge_undertemperature_protection_recovery_T: { min: -40, max: 50, step: 0.5, unit: \"°C\" },\n    power_tube_overtemperature_protection_T: { min: 30, max: 100, step: 0.5, unit: \"°C\" },\n    power_tube_overtemperature_protection_recovery_T: { min: 30, max: 100, step: 0.5, unit: \"°C\" },\n    cell_count_N: { min: 1, max: 32, step: 1, unit: \"\" },\n    Connexion_wire_resistance_1_R: { min: 0, max: 1000, step: 0.1, unit: \"mΩ\" },\n    Device_address_N: { min: 1, max: 247, step: 1, unit: \"\" }\n};\n\n// ------------------------------------------------------------------\n// Fonctions utilitaires\nfunction formatBoolean(val) {\n    if (typeof val === 'boolean') return val ? 'True' : 'False';\n    const v = String(val).toLowerCase();\n    return v === 'true' ? 'True' : v === 'false' ? 'False' : val;\n}\n\nfunction buildDiscoveryMessages(payloadObj) {\n    const msgs = [];\n    for (const key in payloadObj) {\n        if (key === \"0x1114\") continue; // 🔹 Ignore cette clé\n\n        const cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n        const entityType = key.endsWith(\"_B\") ? \"switch\" : \"number\";\n\n        let cfg = {\n            name: key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \"),\n            unique_id: `${deviceID}_${cleanKey}`,\n            state_topic: `${baseTopic}/control/${cleanKey}/state`,\n            command_topic: `${baseTopic}/control/${cleanKey}/set`,\n            entity_category: \"config\",\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"Setup BMS\",\n                sw_version: \"3.3\"\n            }\n        };\n\n        if (entityType === \"number\") {\n            cfg.mode = \"box\";\n            const bounds = customBounds[key];\n            if (bounds) {\n                cfg.min = bounds.min; cfg.max = bounds.max; cfg.step = bounds.step;\n                if (bounds.unit) cfg.unit_of_measurement = bounds.unit;\n            } else {\n                // règles par défaut\n                if (key.endsWith(\"_V\")) {\n                    cfg.unit_of_measurement = \"V\"; cfg.min = 0; cfg.max = 5; cfg.step = 0.01;\n                } else if (key.endsWith(\"_A\")) {\n                    cfg.unit_of_measurement = \"A\"; cfg.min = 0; cfg.max = 400; cfg.step = 0.1;\n                } else if (key.endsWith(\"_S\")) {\n                    cfg.unit_of_measurement = \"s\"; cfg.min = 0; cfg.max = 3600; cfg.step = 1;\n                } else if (key.endsWith(\"_T\")) {\n                    cfg.unit_of_measurement = \"°C\"; cfg.min = -40; cfg.max = 150; cfg.step = 0.5;\n                } else {\n                    cfg.min = 0; cfg.max = 100; cfg.step = 1;\n                }\n            }\n        } else if (entityType === \"switch\") {\n            cfg.payload_on = \"True\"; cfg.payload_off = \"False\";\n            cfg.state_on = \"True\"; cfg.state_off = \"False\";\n        }\n\n        msgs.push({\n            topic: `${discoveryPrefix}/${entityType}/${deviceID}/${cleanKey}/config`,\n            payload: JSON.stringify(cfg),\n            retain: true\n        });\n    }\n    return msgs;\n}\n\nfunction buildStateMessages(payloadObj) {\n    const msgs = [];\n    for (const key in payloadObj) {\n        if (key === \"0x1114\") continue; // 🔹 Ignore aussi pour les states\n\n        const cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n        msgs.push({\n            topic: `${baseTopic}/control/${cleanKey}/state`,\n            payload: formatBoolean(payloadObj[key]),\n            retain: true\n        });\n    }\n    return msgs;\n}\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 4. Construction des messages\nconst payload = msg.payload;\n\n// 🔹 Supprime la clé \"0x1114\" directement si elle est présente\nif (\"0x1114\" in payload) delete payload[\"0x1114\"];\n\nconst discoveryMsgs = discoveryAlreadySent ? [] : buildDiscoveryMessages(payload);\nconst stateMsgs = buildStateMessages(payload);\n\n// Marquer comme traité si c’est la première fois\nif (!discoveryAlreadySent) {\n    flow.set(discoveryKey, true);\n}\n\nreturn [discoveryMsgs.concat(stateMsgs)];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 1380,
        "wires": [
            [
                "ea72bb742b3422f7",
                "0780657340cd75cc"
            ]
        ]
    },
    {
        "id": "ea72bb742b3422f7",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "MQTT setup",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1310,
        "y": 1380,
        "wires": []
    },
    {
        "id": "0780657340cd75cc",
        "type": "mqtt out",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 1160,
        "y": 1380,
        "wires": []
    },
    {
        "id": "61eadd92484325e7",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Relecture-Trame-2-in",
        "links": [
            "aa260e367192285d"
        ],
        "x": 605,
        "y": 660,
        "wires": [
            [
                "9df6cb4f228ce42d"
            ]
        ]
    },
    {
        "id": "fd734524924bf8a8",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "9e766385cf7c92f6",
        "name": "Autres-topics-out",
        "mode": "link",
        "links": [
            "6957819b1dec75c3"
        ],
        "x": 655,
        "y": 1040,
        "wires": []
    },
    {
        "id": "c6f86ca54e23c581",
        "type": "buffer-parser",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Trame 3",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "uint16le",
                "name": "Cell_1_volt_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_2_volt_V",
                "offset": 8,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_3_volt_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_4_volt_V",
                "offset": 12,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_5_volt_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_6_volt_V",
                "offset": 16,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_7_volt_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_8_volt_V",
                "offset": 20,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_9_volt_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_10_volt_V",
                "offset": 24,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_11_volt_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_12_volt_V",
                "offset": 28,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_13_volt_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_14_volt_V",
                "offset": 32,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_15_volt_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_16_volt_V",
                "offset": 36,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_1_ohm_R",
                "offset": 80,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_2_ohm_R",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_3_ohm_R",
                "offset": 84,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_4_ohm_R",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_5_ohm_R",
                "offset": 88,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_6_ohm_R",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_7_ohm_R",
                "offset": 92,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_8_ohm_R",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_9_ohm_R",
                "offset": 96,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_10_ohm_R",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_11_ohm_R",
                "offset": 100,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_12_ohm_R",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_13_ohm_R",
                "offset": 104,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_14_ohm_R",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_15_ohm_R",
                "offset": 108,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_16_ohm_R",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Mos_temp_T",
                "offset": 144,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Puissance_Totale_W",
                "offset": 154,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Courant_total_A",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_1_temp_T",
                "offset": 162,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_2_temp_T",
                "offset": 164,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Balance_courant_A",
                "offset": 170,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Balance_Action_B",
                "offset": 172,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOC_pourcentage_P",
                "offset": 173,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_restante_Ah",
                "offset": 174,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_batterie_Ah",
                "offset": 178,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Nombre_Cycle_N",
                "offset": 182,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Cycle_Capacite_Ah",
                "offset": 186,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOH_pourcentage_P",
                "offset": 190,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Total_runtime_S",
                "offset": 194,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Charge_B",
                "offset": 198,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Decharge_B",
                "offset": 199,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Balance_B",
                "offset": 200,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "Heating_B",
                "offset": 215,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Tension_Totale_volt_V",
                "offset": 234,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Heating_Current_A",
                "offset": 236,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_3_temp_T",
                "offset": 258,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_4_temp_T",
                "offset": 256,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "charge_status_time_S",
                "offset": 278,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "charge_status_N",
                "offset": 280,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "Cell_Type",
                "offset": 282,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 408,
        "y": 1580,
        "wires": [
            [
                "60a06da8cc236522",
                "15033939a61ddd92",
                "705a77e3b053f7ca",
                "914fc4cee6ebe7ee",
                "8756d698a33880b8"
            ]
        ]
    },
    {
        "id": "a3bd0a6eeb93d67f",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Trame 1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": "3",
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 120,
        "y": 560,
        "wires": [
            [
                "5d8b1329cf980408"
            ]
        ]
    },
    {
        "id": "074c128ffe1701e8",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Trame 2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "20",
        "crontab": "",
        "once": true,
        "onceDelay": "4",
        "topic": "",
        "payload": "01 10 16 20 00 01 02 00 00 D6 F1",
        "payloadType": "str",
        "x": 120,
        "y": 620,
        "wires": [
            [
                "73cf0d220e1de798"
            ]
        ]
    },
    {
        "id": "935c37a416cb0336",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Trame 3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "4",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 120,
        "y": 700,
        "wires": [
            [
                "e45ebcb6cea88b4b"
            ]
        ]
    },
    {
        "id": "f1e5252af3527154",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "GW IP",
        "props": [
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "x": 730,
        "y": 320,
        "wires": [
            [
                "fbd3591a98eafd6d"
            ]
        ]
    },
    {
        "id": "55581e8fd2063a3b",
        "type": "tcp request",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "",
        "server": "",
        "port": "",
        "out": "time",
        "ret": "buffer",
        "splitc": "200",
        "newline": "",
        "trim": false,
        "tls": "",
        "x": 1090,
        "y": 380,
        "wires": [
            [
                "5f1cc6f02653dd86",
                "03d54d1f353534ca",
                "b2892effe9f79e84"
            ]
        ]
    },
    {
        "id": "5f1cc6f02653dd86",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "TCP",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1090,
        "y": 420,
        "wires": []
    },
    {
        "id": "03d54d1f353534ca",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "Serial Out",
        "mode": "link",
        "links": [
            "2621a947da028681"
        ],
        "x": 1195,
        "y": 340,
        "wires": []
    },
    {
        "id": "a632bb3545ad81d5",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 1060,
        "y": 660,
        "wires": [
            [
                "bbfdd16be70fd7b0"
            ],
            [
                "389031f7d149d0e4"
            ]
        ],
        "outputLabels": [
            "Ip Gateway",
            "Serial Port"
        ]
    },
    {
        "id": "389031f7d149d0e4",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "link out 2",
        "mode": "link",
        "links": [
            "19e4f82b41b8041a"
        ],
        "x": 1195,
        "y": 740,
        "wires": []
    },
    {
        "id": "95b5286db50cb893",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "9e766385cf7c92f6",
        "name": "Réponses",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 200,
        "y": 960,
        "wires": []
    },
    {
        "id": "bbfdd16be70fd7b0",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "link out 3",
        "mode": "link",
        "links": [
            "72408cddd3840bf2"
        ],
        "x": 1195,
        "y": 580,
        "wires": []
    },
    {
        "id": "72408cddd3840bf2",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "link in 1",
        "links": [
            "bbfdd16be70fd7b0",
            "0e2831f9e2a8e7cf"
        ],
        "x": 675,
        "y": 380,
        "wires": [
            [
                "3de40e166b34cd30"
            ]
        ]
    },
    {
        "id": "b7c41933feffd518",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 500,
        "y": 560,
        "wires": [
            [],
            [
                "1430199873abea94"
            ]
        ]
    },
    {
        "id": "7fc90ebca81725ca",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 500,
        "y": 620,
        "wires": [
            [],
            [
                "9df6cb4f228ce42d"
            ]
        ]
    },
    {
        "id": "3f472b31a16a5124",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 500,
        "y": 700,
        "wires": [
            [],
            [
                "d84c3f32b5bee13a"
            ]
        ]
    },
    {
        "id": "5d8b1329cf980408",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 290,
        "y": 560,
        "wires": [
            [],
            [
                "b7c41933feffd518"
            ]
        ]
    },
    {
        "id": "73cf0d220e1de798",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 290,
        "y": 620,
        "wires": [
            [],
            [
                "7fc90ebca81725ca"
            ]
        ]
    },
    {
        "id": "e45ebcb6cea88b4b",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 290,
        "y": 700,
        "wires": [
            [],
            [
                "3f472b31a16a5124"
            ]
        ]
    },
    {
        "id": "15033939a61ddd92",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Trame \"data\" to MQTT",
        "func": "// Récupération de l'ID d'esclave depuis les variables globales\nconst slaveId = global.get(\"slaveAddress-Trame3\") || 0x01;\n\n// Conversion de la valeur hexadécimale en décimal si nécessaire\nconst slaveIdNumber = typeof slaveId === 'string' ? parseInt(slaveId, 16) : slaveId;\n\nvar payload = msg.payload;\nvar baseTopic = \"BMS_\" + slaveIdNumber;\nvar discoveryPrefix = \"homeassistant/sensor\";\nvar deviceName = \"BMS_\" + slaveIdNumber;\nvar deviceID = \"BMS_\" + slaveIdNumber + \"_device\";\nvar dynamicDataTopic = `${baseTopic}/donnees_dynamiques`;\n\n// ------------------------------------------------------------------\n// 1. Clé unique par BMS pour éviter les rediscovery répétés\nconst discoveryKey = `discoverySent_BMS_${slaveIdNumber}`;\nconst discoveryAlreadySent = flow.get(discoveryKey) || false;\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 2. Variables de travail\nvar topics = {};\nvar discoveryMsgs = [];\nvar dynamicData = {};\n\n// Clés calculées à ignorer pour le discovery (laissée vide ici)\nconst excludeFromDiscovery = [];\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 3. Traitement des tensions de cellules\nvar cellVoltages = [];\nvar cellKeys = [];\n\nfor (var key in payload) {\n    if (key.includes(\"Cell_\") && key.includes(\"volt\") && key.endsWith(\"_V\")) {\n        let voltage = Number(payload[key]);\n        if (!isNaN(voltage)) {\n            cellVoltages.push(voltage);\n            cellKeys.push(key);\n        }\n    }\n}\n\n// Calculs des statistiques des cellules\nif (cellVoltages.length > 0) {\n    var cellAvgVolt = cellVoltages.reduce((sum, v) => sum + v, 0) / cellVoltages.length;\n    var cellMaxVolt = Math.max(...cellVoltages);\n    var cellMinVolt = Math.min(...cellVoltages);\n    var cellDeltaVolt = cellMaxVolt - cellMinVolt;\n\n    var maxVoltIndex = cellKeys[cellVoltages.indexOf(cellMaxVolt)].match(/Cell_(\\d+)/)[1];\n    var minVoltIndex = cellKeys[cellVoltages.indexOf(cellMinVolt)].match(/Cell_(\\d+)/)[1];\n\n    payload[\"cell_voltage_average_V\"]   = parseFloat(cellAvgVolt.toFixed(3));\n    payload[\"cell_voltage_delta_V\"]     = parseFloat(cellDeltaVolt.toFixed(3));\n    payload[\"cell_voltage_max_number_N\"]= parseInt(maxVoltIndex);\n    payload[\"cell_voltage_min_number_N\"]= parseInt(minVoltIndex);\n\n    // ➜ Tension réelle de la cellule la plus basse\n    payload[\"cell_voltage_min_value_V\"] = parseFloat(cellMinVolt.toFixed(3));\n    \n    // ➜ Nouvelle clé : tension réelle de la cellule la plus haute\n    payload[\"cell_voltage_max_value_V\"] = parseFloat(cellMaxVolt.toFixed(3));\n}\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 3b. Traitement du Total_runtime pour format lisible\nif (payload[\"Total_runtime_S\"] !== undefined) {\n    var totalSeconds = parseInt(payload[\"Total_runtime_S\"]);\n    if (!isNaN(totalSeconds)) {\n        var days = Math.floor(totalSeconds / 86400);\n        var remainingSeconds = totalSeconds % 86400;\n        var hours = Math.floor(remainingSeconds / 3600);\n        var minutes = Math.floor((remainingSeconds % 3600) / 60);\n        \n        // Création du format 300D22H46M\n        payload[\"Total_runtime_formatted_T\"] = `${days}D${hours}H${minutes}M`;\n    }\n}\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 3c. Traitement du charge_status_N : conversion en texte lisible\nif (payload[\"charge_status_N\"] !== undefined) {\n    var statusValue = parseInt(payload[\"charge_status_N\"]);\n    var statusText = \"Unknown\";\n    \n    switch(statusValue) {\n        case 0:\n        case 0x00:\n            statusText = \"Bulk\";\n            break;\n        case 1:\n        case 0x01:\n            statusText = \"Absorption\";\n            break;\n        case 2:\n        case 0x02:\n            statusText = \"Float\";\n            break;\n    }\n    \n    // Création d'une nouvelle clé avec le texte lisible\n    payload[\"charge_status_text_S\"] = statusText;\n}\n\n// Traitement du charge_status_time_S pour format lisible\nif (payload[\"charge_status_time_S\"] !== undefined) {\n    var statusSeconds = parseInt(payload[\"charge_status_time_S\"]);\n    if (!isNaN(statusSeconds)) {\n        var days = Math.floor(statusSeconds / 86400);\n        var remainingSeconds = statusSeconds % 86400;\n        var hours = Math.floor(remainingSeconds / 3600);\n        var minutes = Math.floor((remainingSeconds % 3600) / 60);\n        var seconds = remainingSeconds % 60;\n        \n        // Création du format lisible\n        if (days > 0) {\n            payload[\"charge_status_time_formatted_T\"] = `${days}D${hours}H${minutes}M`;\n        } else if (hours > 0) {\n            payload[\"charge_status_time_formatted_T\"] = `${hours}H${minutes}M${seconds}S`;\n        } else if (minutes > 0) {\n            payload[\"charge_status_time_formatted_T\"] = `${minutes}M${seconds}S`;\n        } else {\n            payload[\"charge_status_time_formatted_T\"] = `${seconds}S`;\n        }\n    }\n}\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 4. Création des messages de données et (si besoin) de discovery\nconst allowedSuffixes = [\"_V\", \"_A\", \"_W\", \"_T\", \"_Ah\", \"_R\", \"_P\", \"_S\", \"_B\", \"_N\"];\n\nfor (var key in payload) {\n    if (excludeFromDiscovery.includes(key)) continue;\n\n    var hasValidSuffix = allowedSuffixes.some(s => key.endsWith(s));\n    if (!hasValidSuffix) continue;\n\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\");\n    var sensorTopic = `${baseTopic}/${cleanKey}`;\n    topics[sensorTopic] = payload[key];\n    dynamicData[cleanKey] = payload[key];\n\n    if (!discoveryAlreadySent) {\n        var configTopic = `${discoveryPrefix}/${deviceID}_${cleanKey}/config`;\n        var configPayload = {\n            name: cleanKey,\n            unique_id: `${deviceID}_${cleanKey}`,\n            state_topic: sensorTopic,\n            unit_of_measurement: \"\",\n            entity_category: \"diagnostic\",\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: payload.BMS_A || \"rs485 vers MQTT\",\n                sw_version: payload.SW_N || \"3.3\"\n            }\n        };\n\n        if (key.endsWith(\"_V\")) configPayload.unit_of_measurement = \"V\";\n        else if (key.endsWith(\"_Ah\")) configPayload.unit_of_measurement = \"Ah\";\n        else if (key.endsWith(\"_A\")) configPayload.unit_of_measurement = \"A\";\n        else if (key.endsWith(\"_W\")) configPayload.unit_of_measurement = \"W\";\n        else if (key.endsWith(\"_T\")) {\n            // Pour les temps formatés, pas d'unité car c'est déjà dans le format\n            if (key === \"Total_runtime_formatted_T\" || key === \"charge_status_time_formatted_T\") {\n                configPayload.unit_of_measurement = \"\";\n                configPayload.icon = \"mdi:clock-time-eight-outline\";\n            } \n            // Autres cas avec _T = température\n            else {\n                configPayload.unit_of_measurement = \"°C\";\n            }\n        }\n        else if (key.endsWith(\"_R\")) configPayload.unit_of_measurement = \"Ω\";\n        else if (key.endsWith(\"_P\")) {\n            configPayload.unit_of_measurement = \"%\";\n            if (key.startsWith(\"SOC\")) configPayload.device_class = \"battery\";\n        } \n        else if (key.endsWith(\"_S\")) {\n            // Pour charge_status_text_S, c'est du texte sans unité\n            if (key === \"charge_status_text_S\") {\n                configPayload.unit_of_measurement = \"\";\n                configPayload.icon = \"mdi:battery-charging\";\n            } \n            // Pour charge_status_time_S, unité en secondes avec icône timer\n            else if (key === \"charge_status_time_S\") {\n                configPayload.unit_of_measurement = \"s\";\n                configPayload.icon = \"mdi:timer-outline\";\n            }\n            // Autres cas avec _S = secondes par défaut\n            else {\n                configPayload.unit_of_measurement = \"s\";\n            }\n        }\n\n        discoveryMsgs.push({ topic: configTopic, payload: JSON.stringify(configPayload), retain: true });\n    }\n}\n\n// Ajouter les clés calculées aux données dynamiques (sans discovery)\n[\n    \"cell_voltage_average_V\",\n    \"cell_voltage_delta_V\",\n    \"cell_voltage_max_number_N\",\n    \"cell_voltage_min_number_N\",\n    \"cell_voltage_min_value_V\",\n    \"cell_voltage_max_value_V\"\n].forEach(k => {\n    if (payload[k] !== undefined) {\n        var clean = k.replace(/_[A-Z]+$/, \"\");\n        var topic = `${baseTopic}/${clean}`;\n        topics[topic] = payload[k];\n        dynamicData[clean] = payload[k];\n    }\n});\n\n// ------------------------------------------------------------------\n// 5. Préparation des messages à retourner\n// topics[dynamicDataTopic] = JSON.stringify(dynamicData);\n\nvar outputMsgs = [];\nif (!discoveryAlreadySent) {\n    outputMsgs = discoveryMsgs;\n    flow.set(discoveryKey, true);\n}\n\nfor (var t in topics) {\n    outputMsgs.push({ topic: t, payload: topics[t] });\n}\n\nreturn [outputMsgs];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 1580,
        "wires": [
            [
                "d8f9f00da2e3a338",
                "97a3abc79a4c67cd"
            ]
        ]
    },
    {
        "id": "993c2383b70be9f1",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "communication_debug ?",
        "property": "communication_debug",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 490,
        "y": 2000,
        "wires": [
            [
                "9cd19b0cda3b295b",
                "898dd8cf77551382",
                "0b8826e5e66ac591"
            ],
            []
        ],
        "outputLabels": [
            "Vrai",
            "Faux"
        ]
    },
    {
        "id": "0b8826e5e66ac591",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "JK-BMS response: ",
        "active": true,
        "tosidebar": false,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 1960,
        "wires": []
    },
    {
        "id": "898dd8cf77551382",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "host used",
        "active": true,
        "tosidebar": false,
        "console": true,
        "tostatus": false,
        "complete": "host",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 710,
        "y": 2000,
        "wires": []
    },
    {
        "id": "9cd19b0cda3b295b",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "port used",
        "active": true,
        "tosidebar": false,
        "console": true,
        "tostatus": false,
        "complete": "port",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 710,
        "y": 2040,
        "wires": []
    },
    {
        "id": "4c96f83e2c664c74",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "Debug In",
        "links": [
            "b2892effe9f79e84",
            "54c93e67707946a8",
            "eb4d973c278afdbc"
        ],
        "x": 335,
        "y": 2000,
        "wires": [
            [
                "993c2383b70be9f1"
            ]
        ]
    },
    {
        "id": "b2892effe9f79e84",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "debug-out",
        "mode": "link",
        "links": [
            "4c96f83e2c664c74"
        ],
        "x": 1195,
        "y": 380,
        "wires": []
    },
    {
        "id": "54c93e67707946a8",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "debug-out",
        "mode": "link",
        "links": [
            "4c96f83e2c664c74"
        ],
        "x": 525,
        "y": 380,
        "wires": []
    },
    {
        "id": "705a77e3b053f7ca",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Debug-data-in",
        "mode": "link",
        "links": [
            "8eea8a8ef9220c22"
        ],
        "x": 525,
        "y": 1540,
        "wires": []
    },
    {
        "id": "276f29f9528f1322",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "Live current [A] ",
        "active": true,
        "tosidebar": false,
        "console": true,
        "tostatus": false,
        "complete": "live-current",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 2120,
        "wires": []
    },
    {
        "id": "a4215bec9779ed8c",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "communication_debug ?",
        "property": "communication_debug",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 490,
        "y": 2120,
        "wires": [
            [
                "3c1b49123cabedb0"
            ],
            []
        ],
        "outputLabels": [
            "Vrai",
            "Faux"
        ]
    },
    {
        "id": "3c1b49123cabedb0",
        "type": "change",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "Courant",
        "rules": [
            {
                "t": "set",
                "p": "live-current",
                "pt": "msg",
                "to": "payload.Courant_total_A",
                "tot": "msg"
            },
            {
                "t": "delete",
                "p": "payload",
                "pt": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 700,
        "y": 2120,
        "wires": [
            [
                "276f29f9528f1322"
            ]
        ]
    },
    {
        "id": "8eea8a8ef9220c22",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "Debug-data-in",
        "links": [
            "705a77e3b053f7ca",
            "01565a6abef1f0a8"
        ],
        "x": 335,
        "y": 2120,
        "wires": [
            [
                "a4215bec9779ed8c"
            ]
        ]
    },
    {
        "id": "fbd3591a98eafd6d",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 920,
        "y": 320,
        "wires": [
            [
                "55581e8fd2063a3b"
            ],
            []
        ],
        "outputLabels": [
            "Ip Gateway",
            "Serial Port"
        ]
    },
    {
        "id": "fa351cb08a5d02e9",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "e09fcfa37fa58cc8",
        "name": "Setup-to-serial-or-GW-in",
        "links": [
            "1b9d270fb278785c",
            "94d92b48b836576f"
        ],
        "x": 855,
        "y": 100,
        "wires": [
            [
                "bb64089a3c76b396"
            ]
        ]
    },
    {
        "id": "bb64089a3c76b396",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "e09fcfa37fa58cc8",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 970,
        "y": 100,
        "wires": [
            [
                "0e2831f9e2a8e7cf"
            ],
            [
                "6542c8ba28167fbf"
            ]
        ],
        "outputLabels": [
            "Ip Gateway",
            "Serial Port"
        ]
    },
    {
        "id": "0e2831f9e2a8e7cf",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "e09fcfa37fa58cc8",
        "name": "link out 1",
        "mode": "link",
        "links": [
            "72408cddd3840bf2"
        ],
        "x": 1105,
        "y": 100,
        "wires": []
    },
    {
        "id": "6542c8ba28167fbf",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "e09fcfa37fa58cc8",
        "name": "link out 4",
        "mode": "link",
        "links": [
            "19e4f82b41b8041a"
        ],
        "x": 1105,
        "y": 140,
        "wires": []
    },
    {
        "id": "3de40e166b34cd30",
        "type": "change",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "Host & Port",
        "rules": [
            {
                "t": "set",
                "p": "host",
                "pt": "msg",
                "to": "gateway_ip",
                "tot": "global"
            },
            {
                "t": "set",
                "p": "port",
                "pt": "msg",
                "to": "gateway_port",
                "tot": "global"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 770,
        "y": 380,
        "wires": [
            [
                "8c17e9b0cc52aac4"
            ]
        ]
    },
    {
        "id": "1401504164e95430",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "54c718657c13c657",
        "name": "function 3",
        "func": "// Vérifier que nous avons reçu des données\nif (!msg.payload || msg.payload.length < 7) {\n    node.warn(\"Pas de données reçues ou données incomplètes\");\n    return null;\n}\n\nconst response = msg.payload;\n\n// Structure de la réponse Modbus :\n// [0] = Slave ID\n// [1] = Function Code (0x03)\n// [2] = Byte Count (devrait être 2)\n// [3] = RCVTime (Premier byte - Request Charge Voltage Time)\n// [4] = RFVTime (Deuxième byte - Request Float Voltage Time)\n// [5-6] = CRC\n\nconst slaveId = response[0];\nconst functionCode = response[1];\nconst byteCount = response[2];\nconst RCVTime_raw = response[3];  // Premier byte\nconst RFVTime_raw = response[4];  // Deuxième byte\n\n// Conversion avec l'unité 0.1H (diviser par 10 pour obtenir des heures)\nconst RCVTime_hours = RCVTime_raw * 0.1;\nconst RFVTime_hours = RFVTime_raw * 0.1;\n\n// Préparer le message de sortie\nmsg.payload = {\n    address: \"0x1104\",\n    slaveId: slaveId,\n    functionCode: functionCode,\n    raw_response: response,\n    RCVTime: {\n        raw: RCVTime_raw,\n        value: RCVTime_hours,\n        unit: \"h\",\n        description: \"Request Charge Voltage Time\"\n    },\n    RFVTime: {\n        raw: RFVTime_raw,\n        value: RFVTime_hours,\n        unit: \"h\",\n        description: \"Request Float Voltage Time\"\n    }\n};\n\n// Message de debug formaté\nnode.status({\n    fill: \"green\",\n    shape: \"dot\",\n    text: `RCVTime: ${RCVTime_hours}h | RFVTime: ${RFVTime_hours}h`\n});\n\nnode.warn(`Lecture 0x1104 - RCVTime: ${RCVTime_hours}h (raw: ${RCVTime_raw}) | RFVTime: ${RFVTime_hours}h (raw: ${RFVTime_raw})`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 160,
        "y": 2340,
        "wires": [
            [
                "1a8ddebb594458ae"
            ]
        ]
    },
    {
        "id": "1a8ddebb594458ae",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "54c718657c13c657",
        "name": "debug 7",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 320,
        "y": 2340,
        "wires": []
    },
    {
        "id": "9b436a73a13b0cb3",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "54c718657c13c657",
        "name": "Décodage de la réponse et préparation de l'écriture",
        "func": "// Décodage de la réponse et modification de la valeur appropriée\nif (!msg.payload || msg.payload.length < 7) {\n    node.warn(\"Pas de données reçues ou données incomplètes\");\n    return null;\n}\n\nconst response = msg.payload;\n\n// Extraction des valeurs actuelles\nconst currentRCVTime_raw = response[3];  // Premier byte\nconst currentRFVTime_raw = response[4];  // Deuxième byte\n\nnode.warn(`Valeurs actuelles lues - RCVTime: ${currentRCVTime_raw} | RFVTime: ${currentRFVTime_raw}`);\n\n// Récupérer quelle valeur doit être modifiée\nconst fieldToUpdate = flow.get(\"field_to_update\");\nlet newRCVTime_raw = currentRCVTime_raw;\nlet newRFVTime_raw = currentRFVTime_raw;\n\n// Appliquer la modification\nif (fieldToUpdate === \"RCVTime\") {\n    const newValue = flow.get(\"new_RCVTime\");\n    newRCVTime_raw = Math.round(newValue * 10);\n    node.warn(`Modification RCVTime: ${currentRCVTime_raw} -> ${newRCVTime_raw} (${newValue}h)`);\n} else if (fieldToUpdate === \"RFVTime\") {\n    const newValue = flow.get(\"new_RFVTime\");\n    newRFVTime_raw = Math.round(newValue * 10);\n    node.warn(`Modification RFVTime: ${currentRFVTime_raw} -> ${newRFVTime_raw} (${newValue}h)`);\n} else {\n    node.error(\"Champ à modifier non défini\");\n    return null;\n}\n\n// Validation\nif (newRCVTime_raw < 0 || newRCVTime_raw > 100 || newRFVTime_raw < 0 || newRFVTime_raw > 100) {\n    node.error(\"Valeurs hors limites (0-10h)\");\n    return null;\n}\n\n// Passer les nouvelles valeurs au nœud suivant\nmsg.payload = {\n    RCVTime: newRCVTime_raw,\n    RFVTime: newRFVTime_raw\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 2300,
        "wires": [
            [
                "ea5c7b5329c945a4"
            ]
        ]
    },
    {
        "id": "ea5c7b5329c945a4",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "54c718657c13c657",
        "name": "function 4",
        "func": "// Génération de la trame d'écriture Modbus avec les nouvelles valeurs\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01;\nconst rcvRaw = msg.payload.RCVTime;\nconst rfvRaw = msg.payload.RFVTime;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction de la trame sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    0x06,           // Function code (Write Single Register)\n    0x15,           // Register address high byte\n    0x04,           // Register address low byte\n    rcvRaw & 0xFF,  // Value high byte (RCVTime)\n    rfvRaw & 0xFF   // Value low byte (RFVTime)\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nnode.warn(`Écriture registre 0x1504 - RCVTime: ${rcvRaw} | RFVTime: ${rfvRaw}`);\n\nmsg.topic = \"write_voltage_times\";\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 2300,
        "wires": [
            [
                "5ea27536ce8688a6"
            ]
        ]
    },
    {
        "id": "5ea27536ce8688a6",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "54c718657c13c657",
        "name": "debug 8",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 720,
        "y": 2300,
        "wires": []
    },
    {
        "id": "2b4bee671f623f3c",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "54c718657c13c657",
        "name": "function 2",
        "func": "// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x03; // Function Code 3 : Read Holding Registers\nconst registerHigh = 0x15; // Adresse haute de 0x1504\nconst registerLow = 0x04;  // Adresse basse de 0x1504\nconst quantityHigh = 0x00; // Nombre de registres haute (0x0001 = 1 registre)\nconst quantityLow = 0x01;  // Nombre de registres basse\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-1-statiques\";\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 2260,
        "wires": [
            [
                "94d92b48b836576f"
            ]
        ]
    },
    {
        "id": "94d92b48b836576f",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "54c718657c13c657",
        "name": "link out 5",
        "mode": "link",
        "links": [
            "fa351cb08a5d02e9"
        ],
        "x": 455,
        "y": 2260,
        "wires": []
    },
    {
        "id": "58a120471d8b3aa5",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "54c718657c13c657",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 2260,
        "wires": [
            [
                "2b4bee671f623f3c"
            ]
        ]
    },
    {
        "id": "311d7af5080d4a35",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "Trame Alarmes",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 220,
        "y": 1720,
        "wires": []
    },
    {
        "id": "5fc29293a4e477ba",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "alarms",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "alarms",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 1720,
        "wires": []
    },
    {
        "id": "5dff82f5facf29e8",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "9e766385cf7c92f6",
        "name": "trame-alarme-out",
        "mode": "link",
        "links": [
            "785684768df719de"
        ],
        "x": 595,
        "y": 1020,
        "wires": []
    },
    {
        "id": "785684768df719de",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "trame-alarme-in",
        "links": [
            "5dff82f5facf29e8"
        ],
        "x": 85,
        "y": 1760,
        "wires": [
            [
                "311d7af5080d4a35",
                "558093e71cc2db1c"
            ]
        ]
    },
    {
        "id": "6957819b1dec75c3",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "dd313e0f9fd4ef67",
        "name": "Autres-topics-in",
        "links": [
            "fd734524924bf8a8"
        ],
        "x": 825,
        "y": 1040,
        "wires": [
            [
                "6152557feb0eac9a"
            ]
        ]
    },
    {
        "id": "88ab86576ce40ea4",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "debug 13",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 980,
        "y": 1760,
        "wires": []
    },
    {
        "id": "b1a321c3617b6aea",
        "type": "mqtt out",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 820,
        "y": 1760,
        "wires": []
    },
    {
        "id": "9007859fb0b17098",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "AGGREGATION GLOBALE DES ALARMES BMS",
        "func": "// ========== AGGREGATION GLOBALE DES ALARMES BMS ==========\n// Ce nœud agrège les alarmes de tous les BMS et crée un binary_sensor global\n\n// Récupération des données d'alarme du BMS courant\nconst alarmData = msg.alarms;\n\nif (!alarmData || !alarmData.bms_id) {\n    node.error(\"Données d'alarme invalides ou BMS ID manquant\");\n    return null;\n}\n\nconst bmsId = alarmData.bms_id;\n\n// ------------------------------------------------------------------\n// 1. Configuration\nconst TOTAL_BMS = global.get(\"nb_jkbms\") || 4; // Récupération depuis la variable globale\nconst discoveryPrefix = \"homeassistant\";\nconst globalDeviceID = \"BMS_GLOBAL_device\";\nconst globalDeviceName = \"BMS Global\";\n\n// ------------------------------------------------------------------\n// 2. Stockage de l'état des alarmes dans le contexte flow\n// Clé unique pour stocker l'état de chaque BMS\nconst alarmStateKey = `bms_alarm_state_${bmsId}`;\nconst globalDiscoveryKey = \"discoverySent_GLOBAL_ALARM\";\n\n// Stocker l'état actuel de ce BMS\nflow.set(alarmStateKey, {\n    has_alarm: alarmData.has_alarms,\n    alarm_count: alarmData.alarm_count,\n    timestamp: new Date().toISOString(),\n    active_alarms: alarmData.active_alarms\n});\n\n// ------------------------------------------------------------------\n// 3. Calcul de l'état global en parcourant tous les BMS\nlet globalHasAlarm = false;\nlet totalAlarmCount = 0;\nlet alarmedBmsList = [];\n\nfor (let i = 1; i <= TOTAL_BMS; i++) {\n    const stateKey = `bms_alarm_state_${i}`;\n    const bmsState = flow.get(stateKey);\n    \n    if (bmsState && bmsState.has_alarm) {\n        globalHasAlarm = true;\n        totalAlarmCount += bmsState.alarm_count;\n        alarmedBmsList.push(`BMS ${i}`);\n    }\n}\n\n// ------------------------------------------------------------------\n// 4. Fonction de génération du message discovery (une seule fois)\nfunction buildGlobalDiscoveryMessage() {\n    const binarySensorConfig = {\n        name: \"BMS Global Alarm\",\n        unique_id: `${globalDeviceID}_alarm_active`,\n        state_topic: \"BMS_GLOBAL/alarm/state\",\n        payload_on: \"ON\",\n        payload_off: \"OFF\",\n        device_class: \"problem\",\n        icon: \"mdi:battery-alert\",\n        device: {\n            identifiers: [globalDeviceID],\n            name: globalDeviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"JK-BMS Aggregator\",\n            sw_version: \"3.3\"\n        }\n    };\n    \n    return {\n        topic: `${discoveryPrefix}/binary_sensor/${globalDeviceID}/alarm_active/config`,\n        payload: binarySensorConfig,\n        retain: true\n    };\n}\n\n// ------------------------------------------------------------------\n// 5. Fonction de génération du message state\nfunction buildGlobalStateMessage() {\n    return {\n        topic: \"BMS_GLOBAL/alarm/state\",\n        payload: globalHasAlarm ? \"ON\" : \"OFF\",\n        retain: true,\n        qos: 1\n    };\n}\n\n// ------------------------------------------------------------------\n// 6. Construction et envoi des messages\nconst discoveryAlreadySent = flow.get(globalDiscoveryKey) || false;\nconst messages = [];\n\n// Envoyer le discovery une seule fois\nif (!discoveryAlreadySent) {\n    messages.push(buildGlobalDiscoveryMessage());\n    flow.set(globalDiscoveryKey, true);\n    //node.log(`✓ Discovery envoyé pour BMS Global Alarm (${TOTAL_BMS} BMS surveillés)`);\n}\n\n// Toujours envoyer le state\nmessages.push(buildGlobalStateMessage());\n\n// Log de l'état global\nif (globalHasAlarm) {\n    node.warn(`🚨 ALARME GLOBALE: ${totalAlarmCount} alarme(s) sur ${alarmedBmsList.join(\", \")}`);\n} else {\n    //node.log(`✓ BMS Global: Aucune alarme active (${TOTAL_BMS} BMS OK)`);\n}\n\n// Retourner tous les messages (discovery + state)\nreturn [messages];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1820,
        "wires": [
            [
                "9ace53705bb161cf",
                "6b90f1e389dcec6b"
            ]
        ]
    },
    {
        "id": "9ace53705bb161cf",
        "type": "mqtt out",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 800,
        "y": 1820,
        "wires": []
    },
    {
        "id": "aebbfae197c3bc9f",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "",
        "pauseType": "delay",
        "timeout": "100",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 210,
        "y": 1820,
        "wires": [
            [
                "9007859fb0b17098"
            ]
        ]
    },
    {
        "id": "6b90f1e389dcec6b",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "bms_global_alarm",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 990,
        "y": 1820,
        "wires": []
    },
    {
        "id": "a2d4dd9068a4e071",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "Trame \"alarmes\" to MQTT",
        "func": "// ========== MQTT DISCOVERY & STATE - ALARMES JK-BMS ==========\n// Traitement des alarmes avec auto-discovery Home Assistant\n\n// Récupération des données d'alarme\nconst alarmData = msg.alarms;\n\nif (!alarmData || !alarmData.bms_id) {\n    node.error(\"Données d'alarme invalides ou BMS ID manquant\");\n    return null;\n}\n\nconst bmsId = alarmData.bms_id;\n\n// ------------------------------------------------------------------\n// 1. Vérrou : discovery une seule fois par BMS\nconst discoveryKey = `discoverySent_ALARMS_BMS_${bmsId}`;\nconst discoveryAlreadySent = flow.get(discoveryKey) || false;\n\n// ------------------------------------------------------------------\n// 2. Constantes\nconst baseTopic = `BMS_${bmsId}`;\nconst discoveryPrefix = \"homeassistant\";\nconst deviceName = `BMS_${bmsId}`;\nconst deviceID = `BMS_${bmsId}_device`;\n\n// ------------------------------------------------------------------\n// 3. Fonction de génération des messages discovery\nfunction buildAlarmDiscoveryMessages() {\n    const msgs = [];\n    \n    // 3.1 Binary Sensor pour has_alarms\n    const binarySensorConfig = {\n        name: `BMS ${bmsId} Alarm Active`,\n        unique_id: `${deviceID}_alarm_active`,\n        state_topic: `${baseTopic}/alarm/active`,\n        payload_on: \"ON\",\n        payload_off: \"OFF\",\n        device_class: \"problem\",\n        entity_category: \"diagnostic\",\n        enabled_by_default: true,\n        icon: \"mdi:alert-circle\",\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"JK-BMS RS485\",\n            sw_version: \"3.3\"\n        }\n    };\n    \n    msgs.push({\n        topic: `${discoveryPrefix}/binary_sensor/${deviceID}/alarm_active/config`,\n        payload: binarySensorConfig,\n        retain: true\n    });\n    \n    // 3.2 Sensor texte visuel avec emojis\n    const visualStatusConfig = {\n        name: `BMS ${bmsId} Visual Status`,\n        unique_id: `${deviceID}_visual_status`,\n        state_topic: `${baseTopic}/alarm/visual_status`,\n        entity_category: \"diagnostic\",\n        enabled_by_default: true,\n        icon: \"mdi:gauge\",\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"JK-BMS RS485\",\n            sw_version: \"3.3\"\n        }\n    };\n    \n    msgs.push({\n        topic: `${discoveryPrefix}/sensor/${deviceID}/visual_status/config`,\n        payload: visualStatusConfig,\n        retain: true\n    });\n    \n    // 3.3 Sensor texte pour alarm_details.status\n    const textSensorConfig = {\n        name: `BMS ${bmsId} Alarm Status`,\n        unique_id: `${deviceID}_alarm_status`,\n        state_topic: `${baseTopic}/alarm/status`,\n        entity_category: \"diagnostic\",\n        enabled_by_default: true,\n        icon: \"mdi:text-box-outline\",\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"JK-BMS RS485\",\n            sw_version: \"3.3\"\n        }\n    };\n    \n    msgs.push({\n        topic: `${discoveryPrefix}/sensor/${deviceID}/alarm_status/config`,\n        payload: textSensorConfig,\n        retain: true\n    });\n    \n    // 3.4 Sensor pour la liste des alarmes (format JSON)\n    const listSensorConfig = {\n        name: `BMS ${bmsId} Alarm List`,\n        unique_id: `${deviceID}_alarm_list`,\n        state_topic: `${baseTopic}/alarm/list`,\n        entity_category: \"diagnostic\",\n        enabled_by_default: true,\n        icon: \"mdi:format-list-bulleted\",\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"JK-BMS RS485\",\n            sw_version: \"3.3\"\n        }\n    };\n    \n    msgs.push({\n        topic: `${discoveryPrefix}/sensor/${deviceID}/alarm_list/config`,\n        payload: listSensorConfig,\n        retain: true\n    });\n    \n    return msgs;\n}\n\n// ------------------------------------------------------------------\n// 4. Fonction de génération des messages state\nfunction buildAlarmStateMessages() {\n    const msgs = [];\n    \n    // State pour binary_sensor alarm_active\n    // CORRECTION: Envoyer ON/OFF comme défini dans la config discovery\n    msgs.push({\n        topic: `${baseTopic}/alarm/active`,\n        payload: alarmData.has_alarms ? \"ON\" : \"OFF\",\n        retain: true\n    });\n    \n    // State pour sensor visual_status (affichage convivial)\n    const visualStatus = alarmData.has_alarms \n        ? `🚨 ${alarmData.alarm_count} alarme(s)` \n        : \"✅ Aucune alarme\";\n    \n    msgs.push({\n        topic: `${baseTopic}/alarm/visual_status`,\n        payload: visualStatus,\n        retain: true\n    });\n    \n    // State pour sensor texte (status)\n    const statusText = alarmData.alarm_details.status || \"Unknown\";\n    msgs.push({\n        topic: `${baseTopic}/alarm/status`,\n        payload: statusText,\n        retain: true\n    });\n    \n    // State pour la liste des alarmes\n    const alarmList = alarmData.active_alarms.length > 0 \n        ? alarmData.active_alarms.map(a => a.description).join(\", \")\n        : \"\";\n    \n    msgs.push({\n        topic: `${baseTopic}/alarm/list`,\n        payload: alarmList,\n        retain: true\n    });\n    \n    return msgs;\n}\n\n// ------------------------------------------------------------------\n// 5. Construction des messages\nconst discoveryMsgs = discoveryAlreadySent ? [] : buildAlarmDiscoveryMessages();\nconst stateMsgs = buildAlarmStateMessages();\n\n// Marquer le discovery comme envoyé\nif (!discoveryAlreadySent) {\n    flow.set(discoveryKey, true);\n    //node.log(`✓ Discovery envoyé pour BMS ${bmsId} (alarmes)`);\n}\n\n// Log des alarmes actives\nif (alarmData.has_alarms) {\n    node.warn(`⚠️ BMS ${bmsId}: ${alarmData.alarm_count} alarme(s) active(s)`);\n} else {\n    //node.log(`✓ BMS ${bmsId}: Aucune alarme`);\n}\n\n// Retourner tous les messages (discovery + state)\nreturn [discoveryMsgs.concat(stateMsgs)];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 1760,
        "wires": [
            [
                "88ab86576ce40ea4",
                "b1a321c3617b6aea"
            ]
        ]
    },
    {
        "id": "558093e71cc2db1c",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "e17a26b0d2bf5039",
        "name": "trt. réponse alarmes",
        "func": "// Définition des bits d'alarme (0-23)\nconst ALARM_BITS = {\n    0: \"Balancing resistance too high\",\n    1: \"MOS over-temperature protection\",\n    2: \"Number of cells does not match parameter\",\n    3: \"Abnormal current sensor\",\n    4: \"Cell over-voltage protection\",\n    5: \"Battery over-voltage protection\",\n    6: \"Overcurrent charge protection\",\n    7: \"Charge short-circuit protection\",\n    8: \"Over-temperature charge protection\",\n    9: \"Low temperature charge protection\",\n    10: \"Internal communication anomaly\",\n    11: \"Cell under-voltage protection\",\n    12: \"Battery under-voltage protection\",\n    13: \"Overcurrent discharge protection\",\n    14: \"Discharge short-circuit protection\",\n    15: \"Over-temperature discharge protection\",\n    16: \"Charge MOS anomaly\",\n    17: \"Discharge MOS anomaly\",\n    18: \"GPS disconnected\",\n    19: \"Please modify the authorization password in time\",\n    20: \"Discharge activation failure\",\n    21: \"Battery over-temperature alarm\",\n    22: \"Temperature sensor anomaly\",\n    23: \"Parallel module anomaly\"\n};\n\n// Vérifier que c'est bien une réponse de lecture d'alarmes\nif (msg.topic !== \"Trame-Alarmes-BMS\") {\n    return null;\n}\n\n// Vérifier que la réponse est un buffer et a suffisamment de données\n// Format attendu: [SlaveID][FC][ByteCount][Data...][CRC_L][CRC_H]\nif (!Buffer.isBuffer(msg.payload) || msg.payload.length < 7) {\n    node.error(\"Réponse invalide: buffer trop court ou format incorrect\");\n    return null;\n}\n\n// Extraction des données Modbus\nconst slaveId = msg.payload[0];\nconst functionCode = msg.payload[1];\nconst byteCount = msg.payload[2];\n\n// Vérification du nombre d'octets (devrait être 4 pour 2 registres)\nif (byteCount !== 4) {\n    node.error(`Nombre d'octets incorrect: ${byteCount}, attendu: 4`);\n    return null;\n}\n\n// Extraction de la valeur UINT32 (Big Endian)\n// Les 4 octets de données commencent à l'index 3\nconst alarmValue = msg.payload.readUInt32BE(3);\n\n// Extraire les alarmes actives (bits à 1)\nconst activeAlarms = [];\nconst alarmDetails = {};\nconst alarmBits = [];\n\nfor (let bit = 0; bit <= 23; bit++) {\n    if (alarmValue & (1 << bit)) {\n        const alarmDescription = ALARM_BITS[bit];\n        activeAlarms.push({\n            bit: bit,\n            description: alarmDescription\n        });\n        alarmDetails[`BIT${bit}`] = alarmDescription;\n        alarmBits.push(bit);\n    }\n}\n\n// Toujours remplir le champ \"status\"\nif (activeAlarms.length === 0) {\n    alarmDetails.status = \"No BMS alarms\";\n} else {\n    alarmDetails.status = \"🚨 BMS Alarm Alert\";\n}\n\n// Préparer le payload détaillé dans msg.alarms\nmsg.alarms = {\n    bms_id: msg.bmsId || slaveId,\n    timestamp: new Date().toISOString(),\n    slave_id: slaveId,\n    raw_value: alarmValue,\n    raw_hex: '0x' + alarmValue.toString(16).toUpperCase().padStart(8, '0'),\n    raw_binary: alarmValue.toString(2).padStart(24, '0'),\n    alarm_count: activeAlarms.length,\n    has_alarms: activeAlarms.length > 0,\n    active_bits: alarmBits,\n    active_alarms: activeAlarms,\n    alarm_details: alarmDetails\n};\n\n// Payload simplifié pour MQTT\nmsg.payload = {\n    bms_id: msg.bmsId || slaveId,\n    status: activeAlarms.length > 0 ? \"ALARM\" : \"OK\",\n    count: activeAlarms.length,\n    alarms: activeAlarms.map(a => a.description),\n    bits: alarmBits,\n    timestamp: new Date().toISOString()\n};\n\n// Changement du topic pour MQTT\nmsg.topic = `jkbms/alarms/bms${msg.bmsId || slaveId}`;\n\n// Log pour debug (uniquement en cas d'alarmes actives)\nif (activeAlarms.length > 0) {\n    node.warn(`⚠️ BMS #${msg.bmsId || slaveId}: ${activeAlarms.length} alarme(s) active(s) détectée(s)`);\n    activeAlarms.forEach(alarm => {\n        node.warn(`  - BIT${alarm.bit}: ${alarm.description}`);\n    });\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 1760,
        "wires": [
            [
                "5fc29293a4e477ba",
                "aebbfae197c3bc9f",
                "a2d4dd9068a4e071"
            ]
        ]
    },
    {
        "id": "8666d6cf3f8a75cc",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": "3",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 140,
        "wires": [
            [
                "bd13172ab7887f84",
                "5b29999d7fdc4120",
                "e77b486cbdcfe2b9",
                "7020aefa46e32f74",
                "90d3a2c04fa2bc90"
            ]
        ]
    },
    {
        "id": "bd13172ab7887f84",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "discoverySent_BMS_x to undefined",
        "func": "// Réinitialise toutes les clés de discovery au démarrage\nconst keys = flow.keys();\nkeys.forEach(k => {\n    if (k.startsWith(\"discoverySent_BMS_\")) {\n        flow.set(k, undefined);\n    }\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "5b29999d7fdc4120",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "discoverySent_SETUP_BMS_x to undefined",
        "func": "// Réinitialise toutes les clés de discovery au démarrage\nconst keys = flow.keys();\nkeys.forEach(k => {\n    if (k.startsWith(\"discoverySent_SETUP_BMS_\")) {\n        flow.set(k, undefined);\n    }\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "e77b486cbdcfe2b9",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "discoverySent_STATIC_BMS_x to undefined",
        "func": "// Réinitialise toutes les clés de discovery au démarrage\nconst keys = flow.keys();\nkeys.forEach(k => {\n    if (k.startsWith(\"discoverySent_STATIC_BMS_\")) {\n        flow.set(k, undefined);\n    }\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "7020aefa46e32f74",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "discoverySent_ALARMS_BMS_x to undefined",
        "func": "// Réinitialise toutes les clés de discovery au démarrage\nconst keys = flow.keys();\nkeys.forEach(k => {\n    if (k.startsWith(\"discoverySent_ALARMS_BMS_\")) {\n        flow.set(k, undefined);\n    }\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "90d3a2c04fa2bc90",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "discoverySent_GLOBAL_ALARM_x to undefined",
        "func": "flow.set(\"discoverySent_GLOBAL_ALARM\", null);\n//node.warn(\"✓ Verrou discovery réinitialisé\");\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "ae08f365b6a639d5",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "0x1114 LCD+",
        "func": "// Récupérer ou initialiser le tableau\nlet tableau_0x1114 = global.get('0x1114') || [];\n\n// Extraire les données\nlet uint16_value = msg.payload[\"0x1114\"];  // ex: 0x0210 (valeur UINT16)\nlet bms_number = global.get('slaveAddress-Trame2');  // 0 à 15\n//let bms_number = msg.payload[\"Device_address_N\"] ;  // 0 à 15\n\n// Vérifier si ce bms_number existe déjà\nlet index = tableau_0x1114.findIndex(item => item[1] === bms_number);\n\nif (index !== -1) {\n    // Mettre à jour la ligne existante\n    tableau_0x1114[index] = [uint16_value, bms_number];\n} else {\n    // Ajouter une nouvelle ligne\n    tableau_0x1114.push([uint16_value, bms_number]);\n}\n\n// Sauvegarder dans le contexte global\nglobal.set('0x1114', tableau_0x1114);\n\n// Afficher les détails pour debug\nmsg.payload = {\n    bms: bms_number,\n    value: uint16_value,\n    value_hex: \"0x\" + uint16_value.toString(16).toUpperCase().padStart(4, '0'),\n    value_binary: \"0b\" + uint16_value.toString(2).padStart(16, '0'),\n    bit9: (uint16_value & 0x0200) ? 1 : 0  // État du bit 9\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 579,
        "y": 1340,
        "wires": [
            [
                "987af1e78ba9a7d1"
            ]
        ]
    },
    {
        "id": "16f7228e721581da",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Loop Trame 2",
        "func": "let currentAddress = global.get(\"slaveAddress-Trame2\") || 1; // Valeur par défaut : 1\nlet Number_of_BMS = global.get(\"nb_jkbms\") || 1; // Valeur par défaut : 1\n\n// Incrémenter l'adresse, revenir à 1 après 8\ncurrentAddress = currentAddress >= Number_of_BMS ? 1 : currentAddress + 1;\n\nglobal.set(\"slaveAddress-Trame2\", currentAddress);\n\n//node.warn(`Prochaine adresse esclave Trame2 : ${currentAddress}`);\nmsg.payload = currentAddress;\nreturn msg; // Continuer vers le prochain nœud\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 1340,
        "wires": [
            [
                "35900806dc5fb044"
            ]
        ]
    },
    {
        "id": "1c51761e84ee5bb2",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "SerialNb",
        "func": "var BMS = msg.payload.SerialNb_N;\n// Pour debug, affichons la valeur BMS\nnode.warn(`BMS SerialNb: ${BMS} is alive`);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 1160,
        "wires": [
            []
        ]
    },
    {
        "id": "29aa81cab8e98225",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "",
        "pauseType": "delay",
        "timeout": "50",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 210,
        "y": 420,
        "wires": [
            [
                "5e23433b1e088edf"
            ]
        ]
    },
    {
        "id": "dab766c54a57452d",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Trame \"statics\" to MQTT",
        "func": "// Récupération de l'ID d'esclave\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01;\nconst slaveIdNumber = typeof slaveId === 'string' ? parseInt(slaveId, 16) : slaveId;\n\n// ------------------------------------------------------------------\n// 1. Vérrou : discovery une seule fois (cohérent avec l'initialisation)\nconst discoveryKey = `discoverySent_STATIC_BMS_${slaveIdNumber}`;\nconst discoveryAlreadySent = flow.get(discoveryKey) || false;\n\n// ------------------------------------------------------------------\n// 2. Constantes\nconst baseTopic = \"BMS_\" + slaveIdNumber;\nconst discoveryPrefix = \"homeassistant\";\nconst deviceName = \"BMS_\" + slaveIdNumber;\nconst deviceID = \"BMS_\" + slaveIdNumber + \"_device\";\n\n// Champs qui doivent être des \"number\" (configuration)\nconst numberFields = [\n    \"LCD_buzzer_trigger_N\", \n    \"LCD_buzzer_trigger_value_N\", \n    \"LCD_buzzer_release_value_N\",\n    \"Request_Charge_voltage_Time_H\",\n    \"Request_Float_voltage_Time_H\"\n];\n\n// ------------------------------------------------------------------\n// 3. Fonctions de génération\nfunction formatValue(v) {\n    return (typeof v === 'string') ? v : String(v);\n}\n\nfunction buildDiscoveryMessages(payloadObj) {\n    const msgs = [];\n    for (const key in payloadObj) {\n        const cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n        const sensorTopic = `${baseTopic}/state/${cleanKey}`;\n        \n        // Vérifier si c'est un champ \"number\" (configuration)\n        if (numberFields.includes(key)) {\n            const commandTopic = `${baseTopic}/control/${cleanKey}/set`;\n            \n            // Définir la plage selon le champ\n            let min = 0;\n            let max = 100;\n            let unit = \"%\";\n            let step = 1;\n            let icon = \"mdi:tune\";\n            \n            if (key === \"LCD_buzzer_trigger_N\") {\n                max = 25;\n                unit = \"\";\n                icon = \"mdi:volume-high\";\n            } else if (key === \"Request_Charge_voltage_Time_H\" || key === \"Request_Float_voltage_Time_H\") {\n                min = 0;\n                max = 25;\n                step = 0.1;\n                unit = \"h\";\n                icon = \"mdi:timer-outline\";\n            }\n            \n            let cfg = {\n                name: `BMS ${key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \")}`,\n                unique_id: `${deviceID}_static_${cleanKey}`,\n                state_topic: sensorTopic,\n                command_topic: commandTopic,\n                min: min,\n                max: max,\n                step: step,\n                mode: \"box\",\n                entity_category: \"config\",\n                enabled_by_default: true,\n                icon: icon,\n                device: {\n                    identifiers: [deviceID],\n                    name: deviceName,\n                    manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                    model: payloadObj.BMS_A || \"rs485 vers MQTT\",\n                    sw_version: payloadObj.SW_N || \"3.3\"\n                }\n            };\n            \n            // Ajouter l'unité seulement si elle existe\n            if (unit) {\n                cfg.unit_of_measurement = unit;\n            }\n            \n            msgs.push({\n                topic: `${discoveryPrefix}/number/${deviceID}_static/${cleanKey}/config`,\n                payload: JSON.stringify(cfg),\n                retain: true\n            });\n        } else {\n            // Capteur classique (sensor)\n            let cfg = {\n                name: `BMS ${key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \")}`,\n                unique_id: `${deviceID}_static_${cleanKey}`,\n                state_topic: sensorTopic,\n                enabled_by_default: true,\n                // \\u274c SUPPRESSION de \"entity_category: diagnostic\"\n                device: {\n                    identifiers: [deviceID],\n                    name: deviceName,\n                    manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                    model: payloadObj.BMS_A || \"rs485 vers MQTT\",\n                    sw_version: payloadObj.SW_N || \"3.3\"\n                }\n            };\n\n            // unités & classes\n            if (key.endsWith(\"_S\")) {\n                cfg.unit_of_measurement = \"s\";\n                cfg.device_class = \"duration\";\n                cfg.state_class = \"measurement\";\n            } else if (key.endsWith(\"_H\")) {\n                cfg.unit_of_measurement = \"h\";\n                cfg.device_class = \"duration\";\n                cfg.state_class = \"measurement\";\n            } else if (key.endsWith(\"_N\") && key.includes(\"Time\")) {\n                cfg.unit_of_measurement = \"s\";\n                cfg.device_class = \"duration\";\n                cfg.state_class = \"measurement\";\n            } else if (key.endsWith(\"_N\") && !key.includes(\"Serial\")) {\n                cfg.state_class = \"measurement\";\n            }\n\n            // icônes\n            if (key.includes(\"Password\")) cfg.icon = \"mdi:form-textbox-password\";\n            else if (key.includes(\"Serial\")) cfg.icon = \"mdi:barcode\";\n            else if (key.includes(\"protocol\")) cfg.icon = \"mdi:protocol\";\n            else if (key.includes(\"version\") || key.includes(\"SW\") || key.includes(\"FW\"))\n                cfg.icon = \"mdi:numeric-10\";\n            else if (key.includes(\"Uptime\")) {\n                cfg.icon = \"mdi:timer-outline\";\n                cfg.device_class = \"duration\";\n            } else if (key.includes(\"date\")) cfg.icon = \"mdi:calendar\";\n\n            msgs.push({\n                topic: `${discoveryPrefix}/sensor/${deviceID}_static/${cleanKey}/config`,\n                payload: JSON.stringify(cfg),\n                retain: true\n            });\n        }\n    }\n    return msgs;\n}\n\nfunction buildStateMessages(payloadObj) {\n    const msgs = [];\n    for (const key in payloadObj) {\n        const cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n        msgs.push({\n            topic: `${baseTopic}/state/${cleanKey}`,\n            payload: formatValue(payloadObj[key]),\n            retain: true\n        });\n    }\n    return msgs;\n}\n\n// ------------------------------------------------------------------\n// 4. Construction des messages\nconst payload = msg.payload;\n\nvar outputMsgs = [];\n\n// Envoyer les messages de discovery seulement si pas déjà fait\nif (!discoveryAlreadySent) {\n    outputMsgs = buildDiscoveryMessages(payload);\n    flow.set(discoveryKey, true);\n}\n\n// Ajouter les messages de state\nconst stateMsgs = buildStateMessages(payload);\noutputMsgs = outputMsgs.concat(stateMsgs);\n\nreturn [outputMsgs];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 1200,
        "wires": [
            [
                "cb1a7697e8293f75",
                "32a6b862b301b073"
            ]
        ]
    },
    {
        "id": "c054e6c82bc4bb0a",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "1s",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 750,
        "y": 1160,
        "wires": [
            [
                "6ca55c256080e1c0"
            ]
        ]
    },
    {
        "id": "6ca55c256080e1c0",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Loop Trame 1",
        "func": "let currentAddress = global.get(\"slaveAddress-Trame1\") || 1; // Valeur par défaut : 1\nlet Number_of_BMS = global.get(\"nb_jkbms\") || 1; // Valeur par défaut : 1\n\n// Incrémenter l'adresse, revenir à 1 après 8\ncurrentAddress = currentAddress >= Number_of_BMS ? 1 : currentAddress + 1;\n\nglobal.set(\"slaveAddress-Trame1\", currentAddress);\n\n//node.warn(`Prochaine adresse esclave Trame1 : ${currentAddress}`);\nmsg.payload = currentAddress;\nreturn msg; // Continuer vers le prochain nœud\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 1160,
        "wires": [
            [
                "73bb9117fd0b3a8e"
            ]
        ]
    },
    {
        "id": "73bb9117fd0b3a8e",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Trame 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 1160,
        "wires": []
    },
    {
        "id": "35900806dc5fb044",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Trame 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 1340,
        "wires": []
    },
    {
        "id": "00cca2d92bf02b99",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Loop Trame 3",
        "func": "let currentAddress = global.get(\"slaveAddress-Trame3\") || 1; // Valeur par défaut : 1\nlet Number_of_BMS = global.get(\"nb_jkbms\") || 1; // Valeur par défaut : 1\n\n// Incrémenter l'adresse, revenir à 1 après 8\ncurrentAddress = currentAddress >= Number_of_BMS ? 1 : currentAddress + 1;\n\nglobal.set(\"slaveAddress-Trame3\", currentAddress);\n\n// node.warn(`Prochaine adresse esclave Trame3 : ${currentAddress}`);\nmsg.payload = currentAddress;\nreturn msg; // Continuer vers le prochain nœud\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 1540,
        "wires": [
            [
                "884c969712f9982d"
            ]
        ]
    },
    {
        "id": "884c969712f9982d",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Trame 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 1540,
        "wires": []
    },
    {
        "id": "3782b34f573f61fe",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "",
        "pauseType": "delay",
        "timeout": "1.5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 490,
        "y": 760,
        "wires": [
            [
                "02768681f22fb273"
            ]
        ]
    },
    {
        "id": "02768681f22fb273",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "LECTURE DES ALARMES JK-BMS",
        "func": "// ========== FONCTION 1: LECTURE DES ALARMES JK-BMS ==========\n// Lecture de l'adresse 0x12A0 (4778 en décimal) - Registre des alarmes\n// UINT32 sur 4 registres (nous allons lire 2 registres de 16 bits)\n\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame3\") || 0x01;\n\n// Configuration Modbus pour lecture des alarmes\nconst functionCode = 0x03;      // FC3: Read Holding Registers\nconst address = 0x12A0;         // Adresse du registre des alarmes (4778)\nconst registerHigh = (address >> 8) & 0xFF;   // 0x12\nconst registerLow = address & 0xFF;            // 0xA0\nconst quantityHigh = 0x00;\nconst quantityLow = 0x02;       // Lire 2 registres (32 bits)\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\n// Topic pour identifier cette requête dans le switch\nmsg.topic = \"Trame-Alarmes-BMS\";\nmsg.payload = finalBuffer;\n\n// Sauvegarder l'ID du BMS pour le retrouver dans la réponse\nmsg.bmsId = slaveId;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 760,
        "wires": [
            [
                "a632bb3545ad81d5"
            ]
        ]
    },
    {
        "id": "987af1e78ba9a7d1",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "1s",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 750,
        "y": 1340,
        "wires": [
            [
                "16f7228e721581da"
            ]
        ]
    },
    {
        "id": "914fc4cee6ebe7ee",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "1s",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 750,
        "y": 1540,
        "wires": [
            [
                "00cca2d92bf02b99"
            ]
        ]
    },
    {
        "id": "8c17e9b0cc52aac4",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "100ms",
        "pauseType": "rate",
        "timeout": "100",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 930,
        "y": 380,
        "wires": [
            [
                "55581e8fd2063a3b"
            ]
        ]
    },
    {
        "id": "8756d698a33880b8",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Dashboard-Live-Data-Out",
        "mode": "link",
        "links": [
            "90589e2e759450b0"
        ],
        "x": 595,
        "y": 1540,
        "wires": []
    },
    {
        "id": "32f3c0d652235f1c",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Dashboard-Static-Data-Out",
        "mode": "link",
        "links": [
            "41569635140450b8"
        ],
        "x": 625,
        "y": 1160,
        "wires": []
    },
    {
        "id": "96189c0a78b84915",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Dashboard-Settings-Data-Out",
        "mode": "link",
        "links": [
            "87a73731e478e29a"
        ],
        "x": 515,
        "y": 1400,
        "wires": []
    },
    {
        "id": "02dd5257a29af5a6",
        "type": "mqtt out",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 700,
        "y": 260,
        "wires": []
    },
    {
        "id": "aa260e367192285d",
        "type": "link out",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "Relecture-Trame-2-out",
        "mode": "link",
        "links": [
            "61eadd92484325e7"
        ],
        "x": 815,
        "y": 220,
        "wires": []
    },
    {
        "id": "81acf21e86521b86",
        "type": "link out",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "Setup dispatch out",
        "mode": "link",
        "links": [
            "5132d56fbde6fce4"
        ],
        "x": 515,
        "y": 260,
        "wires": []
    },
    {
        "id": "d9252d611463a606",
        "type": "trigger",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "",
        "op1": "réception",
        "op2": "",
        "op1type": "str",
        "op2type": "payl",
        "duration": "2",
        "extend": true,
        "overrideDelay": false,
        "units": "s",
        "reset": "",
        "bytopic": "topic",
        "topic": "topic",
        "outputs": 2,
        "x": 140,
        "y": 220,
        "wires": [
            [
                "32701e033c9ee445"
            ],
            [
                "223504123cb3206a",
                "0e879f0b1033923c"
            ]
        ]
    },
    {
        "id": "32701e033c9ee445",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "debug 17",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 140,
        "y": 180,
        "wires": []
    },
    {
        "id": "8f82452292423562",
        "type": "delay",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 560,
        "y": 220,
        "wires": [
            [
                "02dd5257a29af5a6",
                "d866e088f62e39db"
            ]
        ]
    },
    {
        "id": "d866e088f62e39db",
        "type": "change",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "re-lecture",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "re-lecture",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 700,
        "y": 220,
        "wires": [
            [
                "aa260e367192285d"
            ]
        ]
    },
    {
        "id": "f446b30dc2078f42",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 380,
        "y": 260,
        "wires": []
    },
    {
        "id": "133adc320649ffd0",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write balance starting voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.42)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en valeur entière (échelle 1/1000)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x84,                           // Register address low byte (0x84)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (voltageValue >> 24) & 0xFF,    // Valeur MSB (premier octet)\n        (voltageValue >> 16) & 0xFF,    // Deuxième octet\n        (voltageValue >> 8) & 0xFF,     // Troisième octet\n        voltageValue & 0xFF             // Valeur LSB (dernier octet)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nconst tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\nmsg.topic = \"write_balance_starting_voltage\";\nmsg.payload = generateModbusWriteCommand(tensionAEcrire);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 460,
        "wires": [
            [
                "1b9d270fb278785c",
                "842d499ea9fe3f9c"
            ]
        ]
    },
    {
        "id": "1b9d270fb278785c",
        "type": "link out",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "link out 14",
        "mode": "link",
        "links": [
            "fa351cb08a5d02e9"
        ],
        "x": 885,
        "y": 1400,
        "wires": []
    },
    {
        "id": "0f8129c7962fb889",
        "type": "switch",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Topic Setup",
        "property": "stateTopic_bis",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "control/balance_starting_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/balance_trigger_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_count/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_request_charge_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_request_float_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_soc0_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_soc100_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_overvoltage_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_overvoltage_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_undervoltage_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_undervoltage_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charging_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/discharging_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/balance_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overcurrent_protection_delay/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overcurrent_protection_recovery_time/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overtemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overtemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/discharge_overtemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/discharge_overtemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/power_tube_overtemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/power_tube_overtemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_undertemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_undertemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/max_balance_current/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/max_charge_current/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/max_discharge_current/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/power_off_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/display_always_on_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/disable_pcl_module_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/smart_sleep_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/timed_stored_data_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/smart_sleep_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/lcd_buzzer_trigger/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/lcd_buzzer_trigger_value/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/lcd_buzzer_release_value/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/request_charge_voltage_time/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/request_float_voltage_time/state",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 39,
        "x": 230,
        "y": 1160,
        "wires": [
            [
                "133adc320649ffd0"
            ],
            [
                "5818d18351e2505a"
            ],
            [
                "e1f20160d6873a16"
            ],
            [
                "831223922b6e7a42"
            ],
            [
                "fd1c6b82e6f4c66b"
            ],
            [
                "bb7a17a27dd64e00"
            ],
            [
                "bceacd21b82896e0"
            ],
            [
                "c84672a0371bb1cc"
            ],
            [
                "57c093189c8bb8cb"
            ],
            [
                "bd140493b7942afa"
            ],
            [
                "3317efd75feda45f"
            ],
            [
                "edda4776590c41a7"
            ],
            [
                "c2528c16e766563a"
            ],
            [
                "666ac34f65df37fe"
            ],
            [
                "c939f58b7a5ce3a1"
            ],
            [
                "b9c43c59d83a114b"
            ],
            [
                "834f13ebf4e4b0aa"
            ],
            [
                "a08c1b9678760404"
            ],
            [
                "9877b4d7a594f576"
            ],
            [
                "57a2d5e590849c4c"
            ],
            [
                "b2b2a91d76d8b8ef"
            ],
            [
                "070294cbb6631c51"
            ],
            [
                "18100f82ea9b96e2"
            ],
            [
                "82a079d96e716dfb"
            ],
            [
                "a2d933bf5714917f"
            ],
            [
                "f69bb43232dd2c3b"
            ],
            [
                "e1b5d6daa74cc917"
            ],
            [
                "10d7690719c5a734"
            ],
            [
                "14c2982fd6b4b10b"
            ],
            [
                "ca1db571bf48ece1"
            ],
            [
                "25bbb554698f3085"
            ],
            [
                "d4b59e37e854b67d"
            ],
            [
                "4782063a6f4cbb89"
            ],
            [
                "b4210ea0e3eceeca"
            ],
            [
                "19813c881712a20f"
            ],
            [
                "1d8951e6d5cadaac"
            ],
            [
                "631dc32357e54b02"
            ],
            [
                "4077be501625201b"
            ],
            [
                "9cdaf1add7c8c49f"
            ]
        ]
    },
    {
        "id": "5132d56fbde6fce4",
        "type": "link in",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Setup dispatch in",
        "links": [
            "81acf21e86521b86"
        ],
        "x": 95,
        "y": 620,
        "wires": [
            [
                "0f8129c7962fb889"
            ]
        ]
    },
    {
        "id": "9cdaf1add7c8c49f",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Autre topic setup",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 190,
        "y": 1520,
        "wires": []
    },
    {
        "id": "5818d18351e2505a",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  balance trigger voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 0.08)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en valeur entière (échelle 1/1000)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n   \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x14,                           // Register address low byte (0x14)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (voltageValue >> 24) & 0xFF,    // Valeur MSB (premier octet)\n        (voltageValue >> 16) & 0xFF,    // Deuxième octet\n        (voltageValue >> 8) & 0xFF,     // Troisième octet\n        voltageValue & 0xFF             // Valeur LSB (dernier octet)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 0.001 || tensionAEcrire > 0.009) {\n    msg.error = \"Tension invalide. Valeur attendue entre 0.001V et 0.009V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_balance_trigger_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 500,
        "wires": [
            [
                "1b9d270fb278785c",
                "830726d692b9c886"
            ]
        ]
    },
    {
        "id": "e1f20160d6873a16",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS cell count",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le nombre de cellules (ex: 16)\nfunction generateModbusWriteCommand(cellCount) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // La valeur est utilisée directement, sans échelle\n    const cellValue = parseInt(cellCount);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x6C,                           // Register address low byte (0x6C)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (cellValue >> 24) & 0xFF,       // Valeur MSB (premier octet)\n        (cellValue >> 16) & 0xFF,       // Deuxième octet\n        (cellValue >> 8) & 0xFF,        // Troisième octet\n        cellValue & 0xFF                // Valeur LSB (dernier octet)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction du nombre de cellules et envoi de la trame\nlet nombreCellules = parseInt(msg.payload);\n\n// Validation basique\nif (isNaN(nombreCellules) || nombreCellules < 1 || nombreCellules > 32) {\n    msg.error = \"Nombre de cellules invalide. Valeur attendue entre 1 et 32\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_cell_count\";\nnewMsg.payload = generateModbusWriteCommand(nombreCellules);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 540,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "831223922b6e7a42",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  cell request charge voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n   \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x20,                           // Register address low byte (0x20)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur en hexadécimal\n    node.warn(`Écriture de ${voltage}V soit ${voltageValue}mV`);\n    node.warn(`Valeur en hex: 0x${voltageValue.toString(16)}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_cell_request_charge_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 580,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "fd1c6b82e6f4c66b",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  cell request float voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x24,                           // Register address low byte (0x24)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_cell_request_float_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 620,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "bb7a17a27dd64e00",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell soc0 voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x1C,                           // Register address low byte (0x1C)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_cell_soc0_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 660,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "bceacd21b82896e0",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell soc100 voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x18,                           // Register address low byte (0x18)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_cell_soc100_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 700,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "c84672a0371bb1cc",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell voltage overvoltage protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x0c,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_overvoltage_protection\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 740,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "57c093189c8bb8cb",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell voltage overvoltage recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x10,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_overvoltage_recovery\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 780,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "bd140493b7942afa",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell voltage undervoltage protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x04,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_undervoltage_protection\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 820,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "3317efd75feda45f",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell voltage undervoltage recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x08,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_undervoltage_recovery\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 860,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "edda4776590c41a7",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  Charging switch",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload peut être \"true\"/\"True\"/\"false\"/\"False\" ou true/false\n\nfunction generateModbusWriteCommand(input) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de l'entrée en booléen\n    let isOn = false;\n    if (typeof input === 'string') {\n        isOn = input.toLowerCase() === 'true';\n    } else if (typeof input === 'boolean') {\n        isOn = input;\n    }\n\n    // Debug\n    console.log(\"Input value:\", input);\n    console.log(\"Converted to:\", isOn);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x70,                           // Register address low byte (0x70)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        0x00,                           // Octet de poids fort (MSB)\n        0x00,                           // \n        0x00,                           // \n        isOn ? 1 : 0                    // Octet de poids faible (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'boolean' && typeof msg.payload !== 'string') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: true/false, 'true'/'false', 'True'/'False'\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_balancer_charging_switch\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\n// Debug\nconsole.log(\"Message payload:\", msg.payload);\nconsole.log(\"Type of payload:\", typeof msg.payload);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 900,
        "wires": [
            [
                "1b9d270fb278785c",
                "969bfbdc6ff80482"
            ]
        ]
    },
    {
        "id": "c2528c16e766563a",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS Décharge switch",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload peut être \"true\"/\"True\"/\"false\"/\"False\" ou true/false\n\nfunction generateModbusWriteCommand(input) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de l'entrée en booléen\n    let isOn = false;\n    if (typeof input === 'string') {\n        isOn = input.toLowerCase() === 'true';\n    } else if (typeof input === 'boolean') {\n        isOn = input;\n    }\n\n    // Debug\n    console.log(\"Input value:\", input);\n    console.log(\"Converted to:\", isOn);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x74,                           // Register address low byte (0x74)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        0x00,                           // Octet de poids fort (MSB)\n        0x00,                           // \n        0x00,                           // \n        isOn ? 1 : 0                    // Octet de poids faible (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'boolean' && typeof msg.payload !== 'string') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: true/false, 'true'/'false', 'True'/'False'\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_bms_discharging_switch\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\n// Debug\nconsole.log(\"Message payload:\", msg.payload);\nconsole.log(\"Type of payload:\", typeof msg.payload);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 940,
        "wires": [
            [
                "1b9d270fb278785c",
                "b997b486b520ba66"
            ]
        ]
    },
    {
        "id": "666ac34f65df37fe",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS Balance switch",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload peut être \"true\"/\"True\"/\"false\"/\"False\" ou true/false\n\nfunction generateModbusWriteCommand(input) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de l'entrée en booléen\n    let isOn = false;\n    if (typeof input === 'string') {\n        isOn = input.toLowerCase() === 'true';\n    } else if (typeof input === 'boolean') {\n        isOn = input;\n    }\n\n    // Debug\n    console.log(\"Input value:\", input);\n    console.log(\"Converted to:\", isOn);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x78,                           // Register address low byte (0x78)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        0x00,                           // Octet de poids fort (MSB)\n        0x00,                           // \n        0x00,                           // \n        isOn ? 1 : 0                    // Octet de poids faible (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'boolean' && typeof msg.payload !== 'string') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: true/false, 'true'/'false', 'True'/'False'\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charging_float_mode_switch\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\n// Debug\nconsole.log(\"Message payload:\", msg.payload);\nconsole.log(\"Type of payload:\", typeof msg.payload);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 980,
        "wires": [
            [
                "1b9d270fb278785c",
                "b545eac4a5a827f8"
            ]
        ]
    },
    {
        "id": "c939f58b7a5ce3a1",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS BMS charge overcurrent protection delay",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre en secondes (ex: 4)\n\nfunction generateModbusWriteCommand(seconds) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof seconds !== 'number' || seconds < 0 || !Number.isInteger(seconds)) {\n        throw new Error(\"La valeur d'entrée doit être un entier positif représentant des secondes.\");\n    }\n\n    // Conversion en uint32 (deux registres de 16 bits en Big-Endian)\n    let highWord = (seconds >> 16) & 0xFFFF;\n    let lowWord = seconds & 0xFFFF;\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x30,                           // Register address low byte (0x30)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (highWord >> 8) & 0xFF,         // Octet de poids fort du premier registre\n        highWord & 0xFF,                // Octet de poids faible du premier registre\n        (lowWord >> 8) & 0xFF,          // Octet de poids fort du second registre\n        lowWord & 0xFF                  // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number' || msg.payload < 0 || !Number.isInteger(msg.payload)) {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un entier positif en secondes.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overcurrent_protection_delay\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1020,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "b9c43c59d83a114b",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS charge overcurrent protection recovery time",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre en secondes (ex: 4)\n\nfunction generateModbusWriteCommand(seconds) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof seconds !== 'number' || seconds < 0 || !Number.isInteger(seconds)) {\n        throw new Error(\"La valeur d'entrée doit être un entier positif représentant des secondes.\");\n    }\n\n    // Conversion en uint32 (deux registres de 16 bits en Big-Endian)\n    let highWord = (seconds >> 16) & 0xFFFF;\n    let lowWord = seconds & 0xFFFF;\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x34,                           // Register address low byte (0x30)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (highWord >> 8) & 0xFF,         // Octet de poids fort du premier registre\n        highWord & 0xFF,                // Octet de poids faible du premier registre\n        (lowWord >> 8) & 0xFF,          // Octet de poids fort du second registre\n        lowWord & 0xFF                  // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number' || msg.payload < 0 || !Number.isInteger(msg.payload)) {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un entier positif en secondes.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overcurrent_protection_recovery_time\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1060,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "834f13ebf4e4b0aa",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write charge overtemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x4C,                           // Register address low byte (0x4C)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overtemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 1100,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "a08c1b9678760404",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write charge overtemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x50,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overtemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 1140,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "9877b4d7a594f576",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write discharge overtemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x54,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_discharge_overtemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 1180,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "57a2d5e590849c4c",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write discharge overtemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x58,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_discharge_overtemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1220,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "b2b2a91d76d8b8ef",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write power tube overtemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x64,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_power_tube_overtemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 1260,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "070294cbb6631c51",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write power tube overtemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x68,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_power tube_overtemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1300,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "18100f82ea9b96e2",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write charge undertemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x5C,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_undertemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 1340,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "82a079d96e716dfb",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write charge undertemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x60,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_undertemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 1380,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "a2d933bf5714917f",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write max balance current",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le courant en ampères (ex: 1.5)\nfunction generateModbusWriteCommand(current) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion du courant selon l'échelle (2A = 2000)\n    // Exemple: 1.5A -> 1500\n    const currentValue = Math.round(current * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x48,                           // Register address low byte (0x48)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (currentValue >> 8) & 0xFF,     // Octet 3\n        currentValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${current}A soit ${currentValue} unités`);\n    node.warn(`Valeur en hex: 0x${currentValue.toString(16)}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de courant et envoi de la trame\nlet courantAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(courantAEcrire) || courantAEcrire < 0 || courantAEcrire > 2) {\n    msg.error = \"Courant invalide. Valeur attendue entre 0A et 2A\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_max_balance_current\";\nnewMsg.payload = generateModbusWriteCommand(courantAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1420,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "f69bb43232dd2c3b",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write max charge current",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le courant en ampères (ex: 5)\nfunction generateModbusWriteCommand(current) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion du courant selon l'échelle observée (140A = 140000)\n    // Exemple: 5A -> 5000\n    const currentValue = Math.round(current * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x2C,                           // Register address low byte (0x2C)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32, on envoie les 4 octets (du plus significatif au moins significatif)\n        (currentValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (currentValue >> 16) & 0xFF,    // Octet 2\n        (currentValue >> 8) & 0xFF,     // Octet 3\n        currentValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${current}A soit ${currentValue} unités`);\n    node.warn(`Valeur en hex: 0x${currentValue.toString(16).padStart(8, '0')}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de courant et envoi de la trame\nlet courantAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(courantAEcrire) || courantAEcrire < 0 || courantAEcrire > 150) {\n    msg.error = \"Courant invalide. Valeur attendue entre 0A et 150A\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_max_charge_current\";\nnewMsg.payload = generateModbusWriteCommand(courantAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1460,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "e1b5d6daa74cc917",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS max discharge current",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le courant en ampères (ex: 5)\nfunction generateModbusWriteCommand(current) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion du courant selon l'échelle observée (140A = 140000)\n    // Exemple: 5A -> 5000\n    const currentValue = Math.round(current * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x38,                           // Register address low byte (0x38)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32, on envoie les 4 octets (du plus significatif au moins significatif)\n        (currentValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (currentValue >> 16) & 0xFF,    // Octet 2\n        (currentValue >> 8) & 0xFF,     // Octet 3\n        currentValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${current}A soit ${currentValue} unités`);\n    node.warn(`Valeur en hex: 0x${currentValue.toString(16).padStart(8, '0')}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de courant et envoi de la trame\nlet courantAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(courantAEcrire) || courantAEcrire < 0 || courantAEcrire > 150) {\n    msg.error = \"Courant invalide. Valeur attendue entre 0A et 150A\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_max_discharge_current\";\nnewMsg.payload = generateModbusWriteCommand(courantAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 1500,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "10d7690719c5a734",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS power off voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension en volts (ex: 2.5)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (2.5V -> 2500mV)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x28,                           // Register address low byte (0x28)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32, on envoie les 4 octets (du plus significatif au moins significatif)\n        (voltageValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (voltageValue >> 16) & 0xFF,    // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${voltage}V soit ${voltageValue}mV`);\n    node.warn(`Valeur en hex: 0x${voltageValue.toString(16).padStart(8, '0')}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 1.8 || tensionAEcrire > 3.0) {\n    msg.error = \"Tension invalide. Valeur attendue entre 1.8V et 3.0V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_power_off_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 1540,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "ca1db571bf48ece1",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write PCL_Disable",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setPCLDisabled) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        0x00,       // Data high byte\n        setPCLDisabled ? 0x80 : 0x00  // Data low byte (bit 7 set or unset)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setPCLDisabled = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"PCL_Disable\";\nmsg.payload = generateModbusCommand(setPCLDisabled);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1620,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "25bbb554698f3085",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write smart sleep switch",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setSmartSleepOn) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        0x00,       // Data high byte\n        setSmartSleepOn ? 0x40 : 0x00  // Data low byte (bit 6 set or unset)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setSmartSleepOn = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"Smart_Sleep\";\nmsg.payload = generateModbusCommand(setSmartSleepOn);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1660,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "d4b59e37e854b67d",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write Timed_Stored_Data",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setTimedStoredDataOn) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        setTimedStoredDataOn ? 0x01 : 0x00,  // Data high byte (bit 8 set or unset)\n        0x00        // Data low byte\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setTimedStoredDataOn = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"Timed_Stored_Data\";\nmsg.payload = generateModbusCommand(setTimedStoredDataOn);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1700,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "4782063a6f4cbb89",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS_smart_sleep_voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue : msg.payload contient la tension (exemple : 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de la tension en millivolts (par exemple, 3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x00,                           // Register address low byte (0x00)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en Big Endian (BE), on envoie d'abord les octets de poids fort\n        (voltageValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (voltageValue >> 16) & 0xFF,    // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet smartSleepVoltage = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(smartSleepVoltage) || smartSleepVoltage < 2.5 || smartSleepVoltage > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_smart_sleep_voltage\";\nnewMsg.payload = generateModbusWriteCommand(smartSleepVoltage);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 1740,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "b545eac4a5a827f8",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 18",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 980,
        "wires": []
    },
    {
        "id": "b997b486b520ba66",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 940,
        "wires": []
    },
    {
        "id": "969bfbdc6ff80482",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 11",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 690,
        "y": 900,
        "wires": []
    },
    {
        "id": "223504123cb3206a",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "function 1",
        "func": "// Handle incoming commands from Home Assistant\nvar parameter = msg.topic.split('/')[2]; // Extract parameter name\nvar value = msg.payload;  // Création du stateTopic original\nvar stateTopic = msg.topic.replace('/set', '/state');  \n\n// Récupère le numéro du BMS et met à jour la variable globale\nconst topicParts = msg.topic.split('_');\nconst slaveAddress = parseInt(topicParts[1].split('/')[0]);\nglobal.set('slaveAddress-setup', slaveAddress);  \n\n// Création du stateTopic_bis en retirant \"BMS_n/\" et remplaçant \"/set\" par \"/state\"\nconst stateTopic_bis = msg.topic.replace(/BMS_\\d+\\//, '').replace('/set', '/state');\n\nreturn [\n    { \n        topic: stateTopic, \n        payload: value, \n        retain: true,\n        stateTopic_bis: stateTopic_bis  // Ajoutez stateTopic_bis ici\n    },\n    { \n        payload: { \n            parameter: parameter, \n            value: value\n        } \n    }\n];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 220,
        "wires": [
            [
                "81acf21e86521b86",
                "8f82452292423562",
                "f446b30dc2078f42"
            ]
        ]
    },
    {
        "id": "3b20d857112c188b",
        "type": "inject",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "BMS_n/",
        "props": [
            {
                "p": "topic",
                "v": "[\"control/+/set\",\"BMS_1/control/+/set\",\"BMS_2/control/+/set\",\"BMS_3/control/+/set\",\"BMS_4/control/+/set\",\"BMS_5/control/+/set\",\"BMS_6/control/+/set\",\"BMS_7/control/+/set\",\"BMS_8/control/+/set\",\"BMS_9/control/+/set\",\"BMS_10/control/+/set\",\"BMS_11/control/+/set\",\"BMS_12/control/+/set\",\"BMS_13/control/+/set\",\"BMS_14/control/+/set\",\"BMS_15/control/+/set\"]",
                "vt": "json"
            },
            {
                "p": "action",
                "v": "subscribe",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.2",
        "topic": "",
        "x": 120,
        "y": 100,
        "wires": [
            [
                "b6ad66b9c7594229",
                "0feab4f81e28026c"
            ]
        ]
    },
    {
        "id": "0feab4f81e28026c",
        "type": "mqtt in",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "",
        "topic": "",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "56f7b2737cce493b",
        "nl": false,
        "rap": false,
        "inputs": 1,
        "x": 430,
        "y": 160,
        "wires": [
            [
                "d9252d611463a606"
            ]
        ]
    },
    {
        "id": "842d499ea9fe3f9c",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 30",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 460,
        "wires": []
    },
    {
        "id": "830726d692b9c886",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 6",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 750,
        "y": 500,
        "wires": []
    },
    {
        "id": "37a35ec9033764b1",
        "type": "switch",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 520,
        "y": 100,
        "wires": [
            [],
            [
                "0feab4f81e28026c"
            ]
        ]
    },
    {
        "id": "b6ad66b9c7594229",
        "type": "switch",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 290,
        "y": 100,
        "wires": [
            [],
            [
                "37a35ec9033764b1"
            ]
        ]
    },
    {
        "id": "0e879f0b1033923c",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 140,
        "y": 260,
        "wires": []
    },
    {
        "id": "b4210ea0e3eceeca",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "BMS LCD buzzer trigger",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la valeur (0 à 3)\n\nfunction generateModbusWriteCommand(value) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion en UINT8 (valeur non signée sur 8 bits)\n    const uint8Value = Math.round(value) & 0xFF;\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01;\n    \n    // Pour un UINT8, on écrit 1 registre (16 bits) mais seulement l'octet de poids faible est utilisé\n    const command = [\n        slaveId,                           // Slave ID\n        0x06,                              // Function code (06/0x06 - Write Single Register)\n        0x14,                              // Register address high byte (0x14)\n        0xE4,                              // Register address low byte (0xE4)\n        0x00,                              // Data high byte (0x00 pour UINT8)\n        uint8Value                         // Data low byte (valeur UINT8)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur et envoi de la trame\nlet valeurAEcrire = parseInt(msg.payload);\n\n// Validation basique\nif (isNaN(valeurAEcrire) || valeurAEcrire < 0 || valeurAEcrire > 12) {\n    msg.error = \"Valeur invalide. Valeur attendue entre 0 et 12\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_lcd_buzzer_trigger\";\nnewMsg.payload = generateModbusWriteCommand(valeurAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1780,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "19813c881712a20f",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "BMS LCD buzzer trigger value",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le pourcentage (0 à 100)\n\nfunction generateModbusWriteCommand(percentage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion en INT32 (valeur signée sur 32 bits)\n    const value = Math.round(percentage);\n    \n    // Conversion INT32 en buffer 4 octets (Big Endian)\n    const buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(value, 0);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01;\n    \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                              // Function code (16/0x10 - Write Multiple Registers)\n        0x14,                              // Register address high byte (0x14)\n        0xE8,                              // Register address low byte (0xE8)\n        0x00,                              // Quantity high byte (2 registres pour int32)\n        0x02,                              // Quantity low byte (2 registres pour int32)\n        0x04,                              // Byte count (4 bytes pour int32)\n        buffer[0],                         // Octet 1 (MSB)\n        buffer[1],                         // Octet 2\n        buffer[2],                         // Octet 3\n        buffer[3]                          // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de pourcentage et envoi de la trame\nlet percentageAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(percentageAEcrire) || percentageAEcrire < 0 || percentageAEcrire > 100) {\n    msg.error = \"Valeur invalide. Pourcentage attendu entre 0 et 100\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_lcd_buzzer_trigger_value\";\nnewMsg.payload = generateModbusWriteCommand(percentageAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 1820,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "1d8951e6d5cadaac",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "BMS LCD buzzer release value",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le pourcentage (0 à 100)\n\nfunction generateModbusWriteCommand(percentage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion en INT32 (valeur signée sur 32 bits)\n    const value = Math.round(percentage);\n    \n    // Conversion INT32 en buffer 4 octets (Big Endian)\n    const buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(value, 0);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01;\n    \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                              // Function code (16/0x10 - Write Multiple Registers)\n        0x14,                              // Register address high byte (0x14)\n        0xEC,                              // Register address low byte (0xEC)\n        0x00,                              // Quantity high byte (2 registres pour int32)\n        0x02,                              // Quantity low byte (2 registres pour int32)\n        0x04,                              // Byte count (4 bytes pour int32)\n        buffer[0],                         // Octet 1 (MSB)\n        buffer[1],                         // Octet 2\n        buffer[2],                         // Octet 3\n        buffer[3]                          // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de pourcentage et envoi de la trame\nlet percentageAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(percentageAEcrire) || percentageAEcrire < 0 || percentageAEcrire > 100) {\n    msg.error = \"Valeur invalide. Pourcentage attendu entre 0 et 100\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_lcd_buzzer_release_value\";\nnewMsg.payload = generateModbusWriteCommand(percentageAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 1860,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "631dc32357e54b02",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "request charge voltage time",
        "func": "// Génération de la trame de lecture Modbus 0x1504\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01;\nconst functionCode = 0x03;\nconst registerHigh = 0x15;\nconst registerLow = 0x04;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"read_before_write\";\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 1900,
        "wires": [
            [
                "54b01d2a7d5b9841",
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "4077be501625201b",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "request float voltage time",
        "func": "// Génération de la trame de lecture Modbus 0x1504\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01;\nconst functionCode = 0x03;\nconst registerHigh = 0x15;\nconst registerLow = 0x04;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"read_before_write\";\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1940,
        "wires": [
            [
                "1c9fa4df6d24ab3c",
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "54b01d2a7d5b9841",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "request charge voltage time",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 1900,
        "wires": []
    },
    {
        "id": "1c9fa4df6d24ab3c",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "request float voltage time",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 790,
        "y": 1940,
        "wires": []
    },
    {
        "id": "14c2982fd6b4b10b",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Tableau 0x1114 LCD & Co",
        "func": "// Extraire le numéro de BMS du topic\nlet topic = msg.topic;  // Exemple : \"BMS_2/control/display_always_on_switch/state\"\nlet bms_match = topic.match(/BMS_(\\d+)\\//);\nlet bms_id = bms_match ? parseInt(bms_match[1]) : null;\n\nif (bms_id === null) {\n    node.error(\"Numéro de BMS non trouvé dans le topic\");\n    return null;\n}\n\n// Extraire l'état demandé (True / False)\nlet display_on = (msg.payload === \"True\" || msg.payload === true);\n\n// Récupérer le tableau stocké\nlet tableau_0x1114 = global.get('0x1114') || [];\n\n// Chercher la valeur actuelle pour ce BMS\nlet bms_data = tableau_0x1114.find(item => item[1] === bms_id);\n\nif (!bms_data) {\n    node.error(\"BMS #\" + bms_id + \" non trouvé dans le tableau\");\n    return null;\n}\n\n// Valeur actuelle du registre (UINT16)\nlet current_value = bms_data[0];\n\n// Modifier le bit 4 (masque 0x0010 = 0b0000000000010000)\nlet mask = 0x0010;\nlet new_value;\nif (display_on) {\n    new_value = current_value | mask;   // Allumer LCD\n} else {\n    new_value = current_value & ~mask;  // Éteindre LCD\n}\n\n// Mettre à jour le tableau avec la nouvelle valeur\nbms_data[0] = new_value;\nglobal.set('0x1114', tableau_0x1114);\n\n// --- Construction de la trame Modbus (Function Code 0x10 - Write Multiple Registers) ---\nlet slave_address = bms_id;\nlet function_code = 0x10;\nlet register_address = 0x1114;\n\nlet register_hi = (register_address >> 8) & 0xFF;\nlet register_lo = register_address & 0xFF;\nlet quantity_hi = 0x00;\nlet quantity_lo = 0x01;\nlet byte_count = 0x02;\n\nlet value_hi = (new_value >> 8) & 0xFF;\nlet value_lo = new_value & 0xFF;\n\n// --- Calcul du CRC16 Modbus ---\nfunction calculateCRC16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Créer le buffer sans CRC\nlet data_buffer = [\n    slave_address, function_code, register_hi, register_lo,\n    quantity_hi, quantity_lo, byte_count, value_hi, value_lo\n];\n\n// Calculer CRC\nlet crc = calculateCRC16(data_buffer);\nlet crc_lo = crc & 0xFF;\nlet crc_hi = (crc >> 8) & 0xFF;\n\n// Trame Modbus complète\nlet modbus_frame = Buffer.from([\n    slave_address, function_code, register_hi, register_lo,\n    quantity_hi, quantity_lo, byte_count, value_hi, value_lo, crc_lo, crc_hi\n]);\n\n// Préparer le message de sortie\nmsg.payload = modbus_frame;\nmsg.bms_id = bms_id;\nmsg.register = \"0x1114\";\nmsg.new_value = new_value;\nmsg.new_value_hex = \"0x\" + new_value.toString(16).toUpperCase().padStart(4, '0');\nmsg.new_value_binary = \"0b\" + new_value.toString(2).padStart(16, '0');\nmsg.display_on = display_on;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 1580,
        "wires": [
            [
                "c2a965eb88a133a6",
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "c2a965eb88a133a6",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "LCD action",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1580,
        "wires": []
    },
    {
        "id": "24f7bb18c1109510",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "Modbus Out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 170,
        "y": 580,
        "wires": []
    },
    {
        "id": "74c53c8fdd7c6f6e",
        "type": "link in",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "Broadcast-in",
        "links": [
            "44c1946af35b4bf2",
            "a760f49cb3f03843"
        ],
        "x": 115,
        "y": 780,
        "wires": [
            [
                "88b164ac7026be0e",
                "40053a1d91143e21",
                "eb4d973c278afdbc"
            ]
        ]
    },
    {
        "id": "1bb4998cb85dda4e",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "data-out",
        "mode": "link",
        "links": [
            "e207f8c07a156191"
        ],
        "x": 925,
        "y": 800,
        "wires": []
    },
    {
        "id": "a65a870d600bb230",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "setup-out",
        "mode": "link",
        "links": [
            "a4be995f90fc779c"
        ],
        "x": 925,
        "y": 760,
        "wires": []
    },
    {
        "id": "bc098ac8e7c2a80e",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Trame 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 240,
        "y": 1240,
        "wires": []
    },
    {
        "id": "e207f8c07a156191",
        "type": "link in",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "data-in",
        "links": [
            "1bb4998cb85dda4e"
        ],
        "x": 115,
        "y": 1200,
        "wires": [
            [
                "bc098ac8e7c2a80e",
                "2773a8c67764f19a",
                "7d85cec3b8e788bf"
            ]
        ]
    },
    {
        "id": "ace79b04ef5d3953",
        "type": "mqtt out",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 760,
        "y": 1200,
        "wires": []
    },
    {
        "id": "b8c6447a9aadb290",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "debug 15",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 1260,
        "wires": []
    },
    {
        "id": "6ac6b1debaf96f4e",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Trame Data",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 1240,
        "wires": []
    },
    {
        "id": "e3768062bfabfaf0",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Data To MQTT",
        "func": "// =========== BMS DATA PROCESSING - CORRECTED VERSION ===========\n\n// 0. Récupération adresse BMS et conversion en \"master\" si nécessaire\nlet bmsAdresse = msg.bms_numero;\nlet slaveIdStr;\n\nif (typeof bmsAdresse === \"string\" && bmsAdresse.toLowerCase() === \"master\") {\n    slaveIdStr = \"master\";\n} else if (!isNaN(Number(bmsAdresse))) {\n    // Si c'est 0, remplacer par \"master\"\n    if (Number(bmsAdresse) === 0) {\n        slaveIdStr = \"master\";\n    } else {\n        slaveIdStr = String(Number(bmsAdresse));\n    }\n} else {\n    slaveIdStr = \"master\";  // fallback\n}\n\nvar payload = msg.payload;\nvar baseTopic = \"BMS_\" + slaveIdStr;\nvar discoveryPrefix = \"homeassistant/sensor\";\nvar deviceName = \"BMS_\" + slaveIdStr;\nvar deviceID = \"BMS_\" + slaveIdStr + \"_device\";\n\nvar topics = {};\nvar discoveryMsgs = [];\nvar dynamicData = {};\n\n// ===== CORRECTION #1 : Vérifier AVANT si discovery a été envoyé =====\nconst discoveryKey = `discoverySent_BMS_${slaveIdStr}`;\nlet discoveryAlreadySent = flow.get(discoveryKey) || false;\n\n// 2. Traitement des tensions de cellules\nvar cellVoltages = [];\nvar cellKeys = [];\n\nfor (var key in payload) {\n    if (key.includes(\"Cell_\") && key.includes(\"volt\") && key.endsWith(\"_V\")) {\n        let voltage = Number(payload[key]);\n        if (!isNaN(voltage)) {\n            cellVoltages.push(voltage);\n            cellKeys.push(key);\n        }\n    }\n}\n\nif (cellVoltages.length > 0) {\n    var cellAvgVolt = cellVoltages.reduce((sum, v) => sum + v, 0) / cellVoltages.length;\n    var cellMaxVolt = Math.max(...cellVoltages);\n    var cellMinVolt = Math.min(...cellVoltages);\n    var cellDeltaVolt = cellMaxVolt - cellMinVolt;\n\n    var maxVoltIndex = cellKeys[cellVoltages.indexOf(cellMaxVolt)].match(/Cell_(\\d+)/)[1];\n    var minVoltIndex = cellKeys[cellVoltages.indexOf(cellMinVolt)].match(/Cell_(\\d+)/)[1];\n\n    payload[\"cell_voltage_average_V\"]   = parseFloat(cellAvgVolt.toFixed(3));\n    payload[\"cell_voltage_delta_V\"]     = parseFloat(cellDeltaVolt.toFixed(3));\n    payload[\"cell_voltage_max_number_N\"]= parseInt(maxVoltIndex);\n    payload[\"cell_voltage_min_number_N\"]= parseInt(minVoltIndex);\n    payload[\"cell_voltage_min_value_V\"] = parseFloat(cellMinVolt.toFixed(3));\n    payload[\"cell_voltage_max_value_V\"] = parseFloat(cellMaxVolt.toFixed(3));\n}\n\n// 3. Formatage de Total_runtime_S\nif (payload[\"Total_runtime_S\"] !== undefined) {\n    var totalSeconds = parseInt(payload[\"Total_runtime_S\"]);\n    if (!isNaN(totalSeconds)) {\n        var days = Math.floor(totalSeconds / 86400);\n        var remainingSeconds = totalSeconds % 86400;\n        var hours = Math.floor(remainingSeconds / 3600);\n        var minutes = Math.floor((remainingSeconds % 3600) / 60);\n        payload[\"Total_runtime_formatted_T\"] = `${days}D${hours}H${minutes}M`;\n    }\n}\n\n// 4. charge_status_N → texte lisible\nif (payload[\"charge_status_N\"] !== undefined) {\n    var v = parseInt(payload[\"charge_status_N\"]);\n    var txt = \"Unknown\";\n    switch(v) {\n        case 0: case 0x00: txt = \"Bulk\"; break;\n        case 1: case 0x01: txt = \"Absorption\"; break;\n        case 2: case 0x02: txt = \"Float\"; break;\n    }\n    payload[\"charge_status_text_S\"] = txt;\n}\n\n// 5. Formatage charge_status_time_S\nif (payload[\"charge_status_time_S\"] !== undefined) {\n    var s = parseInt(payload[\"charge_status_time_S\"]);\n    if (!isNaN(s)) {\n        var days = Math.floor(s / 86400);\n        var rem = s % 86400;\n        var hours = Math.floor(rem / 3600);\n        var minutes = Math.floor((rem % 3600) / 60);\n        var seconds = rem % 60;\n\n        if (days > 0)\n            payload[\"charge_status_time_formatted_T\"] = `${days}D${hours}H${minutes}M`;\n        else if (hours > 0)\n            payload[\"charge_status_time_formatted_T\"] = `${hours}H${minutes}M${seconds}S`;\n        else if (minutes > 0)\n            payload[\"charge_status_time_formatted_T\"] = `${minutes}M${seconds}S`;\n        else\n            payload[\"charge_status_time_formatted_T\"] = `${seconds}S`;\n    }\n}\n\n// 6. Formatage Heating_B\nif (payload[\"Heating_B\"] !== undefined) {\n    var heatingStatus = parseInt(payload[\"Heating_B\"]);\n    var heatingTxt = heatingStatus === 1 ? \"ON\" : \"OFF\";\n    payload[\"Heating_status_text_S\"] = heatingTxt;\n}\n\n// 7. Génération des topics MQTT + discovery\nconst allowedSuffixes = [\"_V\", \"_A\", \"_W\", \"_T\", \"_Ah\", \"_R\", \"_P\", \"_S\", \"_B\", \"_N\"];\n\nfor (var key in payload) {\n    var hasValidSuffix = allowedSuffixes.some(s => key.endsWith(s));\n    if (!hasValidSuffix) continue;\n\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\");\n    var sensorTopic = `${baseTopic}/${cleanKey}`;\n    topics[sensorTopic] = payload[key];\n    dynamicData[cleanKey] = payload[key];\n\n    // ===== CORRECTION #2 : Générer discovery pour TOUS les capteurs =====\n    if (!discoveryAlreadySent) {\n        var configTopic = `${discoveryPrefix}/${deviceID}_${cleanKey}/config`;\n\n        var configPayload = {\n            name: cleanKey,\n            unique_id: `${deviceID}_${cleanKey}`,\n            state_topic: sensorTopic,\n            unit_of_measurement: \"\",\n            entity_category: \"diagnostic\",\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"JK-BMS - RS485\",\n                sw_version: \"3.3\"\n            }\n        };\n\n        // Gestion des unités\n        if (key.endsWith(\"_V\")) configPayload.unit_of_measurement = \"V\";\n        else if (key.endsWith(\"_Ah\")) configPayload.unit_of_measurement = \"Ah\";\n        else if (key.endsWith(\"_A\")) configPayload.unit_of_measurement = \"A\";\n        else if (key.endsWith(\"_W\")) configPayload.unit_of_measurement = \"W\";\n        else if (key.endsWith(\"_R\")) configPayload.unit_of_measurement = \"Ω\";\n        else if (key.endsWith(\"_P\")) {\n            configPayload.unit_of_measurement = \"%\";\n            if (key.startsWith(\"SOC\")) configPayload.device_class = \"battery\";\n        }\n        // --- BOOLÉENS (_B) : CONFIGURATION COMPLÈTE ---\n        else if (key.endsWith(\"_B\")) {\n            configPayload.unit_of_measurement = \"\";\n            configPayload.icon = \"mdi:toggle-switch\";\n            \n            if (key === \"Heating_B\") {\n                configPayload.device_class = \"heat\";\n                configPayload.icon = \"mdi:heating-coil\";\n            } else if (key === \"Switch_Charge_B\") {\n                configPayload.icon = \"mdi:battery-charging\";\n            } else if (key === \"Switch_Decharge_B\") {\n                configPayload.icon = \"mdi:battery-minus\";\n            } else if (key === \"Balance_Action_B\") {\n                configPayload.icon = \"mdi:battery-sync\";\n            } else if (key === \"Switch_Balance_B\") {\n                configPayload.icon = \"mdi:battery-balance\";\n            }\n        }\n        // --- TEMPS (_T) ---\n        else if (key.endsWith(\"_T\")) {\n            if (key === \"Total_runtime_formatted_T\" ||\n                key === \"charge_status_time_formatted_T\") {\n                configPayload.unit_of_measurement = \"\";\n                configPayload.icon = \"mdi:clock-time-eight-outline\";\n            } else {\n                configPayload.unit_of_measurement = \"°C\";\n            }\n        }\n        // --- TEXTE (_S) ---\n        else if (key.endsWith(\"_S\")) {\n            if (key === \"charge_status_text_S\") {\n                configPayload.unit_of_measurement = \"\";\n                configPayload.icon = \"mdi:battery-charging\";\n            } \n            else if (key === \"Heating_status_text_S\") {\n                configPayload.unit_of_measurement = \"\";\n                configPayload.icon = \"mdi:heating-coil\";\n            }\n            else if (key === \"charge_status_time_S\") {\n                configPayload.unit_of_measurement = \"s\";\n                configPayload.icon = \"mdi:timer-outline\";\n            } \n            else {\n                configPayload.unit_of_measurement = \"s\";\n            }\n        }\n        // --- NOMBRES (_N) ---\n        else if (key.endsWith(\"_N\")) {\n            configPayload.unit_of_measurement = \"\";\n            configPayload.icon = \"mdi:counter\";\n        }\n\n        discoveryMsgs.push({\n            topic: configTopic,\n            payload: JSON.stringify(configPayload),\n            retain: true\n        });\n    }\n}\n\n// 8. Ajouter les valeurs calculées\n[\n    \"cell_voltage_average_V\",\n    \"cell_voltage_delta_V\",\n    \"cell_voltage_max_number_N\",\n    \"cell_voltage_min_number_N\",\n    \"cell_voltage_min_value_V\",\n    \"cell_voltage_max_value_V\",\n    \"Heating_status_text_S\"\n].forEach(k => {\n    if (payload[k] !== undefined) {\n        let cleanKey = k.replace(/_[A-Z]+$/, \"\");\n        let topic = `${baseTopic}/${cleanKey}`;\n        topics[topic] = payload[k];\n        dynamicData[cleanKey] = payload[k];\n    }\n});\n\n// 9. Sortie\nvar outputMsgs = [];\n\nif (!discoveryAlreadySent) {\n    outputMsgs = discoveryMsgs;\n    flow.set(discoveryKey, true);\n    node.warn(`✓ Discovery envoyé pour BMS ${slaveIdStr} (${discoveryMsgs.length} sensors)`);\n} else {\n    node.debug(`Discovery déjà envoyé pour BMS ${slaveIdStr}`);\n}\n\nfor (var t in topics) {\n    outputMsgs.push({ topic: t, payload: topics[t] });\n}\n\nreturn [outputMsgs];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 1200,
        "wires": [
            [
                "b8c6447a9aadb290",
                "ace79b04ef5d3953"
            ]
        ]
    },
    {
        "id": "2773a8c67764f19a",
        "type": "buffer-parser",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Trame 3",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "uint16le",
                "name": "Cell_1_volt_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_2_volt_V",
                "offset": 8,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_3_volt_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_4_volt_V",
                "offset": 12,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_5_volt_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_6_volt_V",
                "offset": 16,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_7_volt_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_8_volt_V",
                "offset": 20,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_9_volt_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_10_volt_V",
                "offset": 24,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_11_volt_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_12_volt_V",
                "offset": 28,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_13_volt_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_14_volt_V",
                "offset": 32,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_15_volt_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_16_volt_V",
                "offset": 36,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_1_ohm_R",
                "offset": 80,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_2_ohm_R",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_3_ohm_R",
                "offset": 84,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_4_ohm_R",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_5_ohm_R",
                "offset": 88,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_6_ohm_R",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_7_ohm_R",
                "offset": 92,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_8_ohm_R",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_9_ohm_R",
                "offset": 96,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_10_ohm_R",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_11_ohm_R",
                "offset": 100,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_12_ohm_R",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_13_ohm_R",
                "offset": 104,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_14_ohm_R",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_15_ohm_R",
                "offset": 108,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_16_ohm_R",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Mos_temp_T",
                "offset": 144,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Puissance_Totale_W",
                "offset": 154,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Courant_total_A",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_1_temp_T",
                "offset": 162,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_2_temp_T",
                "offset": 164,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Balance_courant_A",
                "offset": 170,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Balance_Action_B",
                "offset": 172,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOC_pourcentage_P",
                "offset": 173,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_restante_Ah",
                "offset": 174,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_batterie_Ah",
                "offset": 178,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Nombre_Cycle_N",
                "offset": 182,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Cycle_Capacite_Ah",
                "offset": 186,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOH_pourcentage_P",
                "offset": 190,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Total_runtime_S",
                "offset": 194,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Charge_B",
                "offset": 198,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Decharge_B",
                "offset": 199,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Balance_B",
                "offset": 200,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "Heating_B",
                "offset": 215,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Heating_Current_A",
                "offset": 236,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Tension_Totale_volt_V",
                "offset": 234,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_3_temp_T",
                "offset": 254,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_4_temp_T",
                "offset": 258,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "charge_status_time_S",
                "offset": 278,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "charge_status_N",
                "offset": 280,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 240,
        "y": 1200,
        "wires": [
            [
                "6ac6b1debaf96f4e",
                "e3768062bfabfaf0",
                "01565a6abef1f0a8",
                "62299fe8aa268603"
            ]
        ]
    },
    {
        "id": "d0b96287555baddd",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Trame Setup",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 1020,
        "wires": []
    },
    {
        "id": "5379d0376efbcee9",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Trame 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 240,
        "y": 1020,
        "wires": []
    },
    {
        "id": "a4be995f90fc779c",
        "type": "link in",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "setup-in",
        "links": [
            "a65a870d600bb230"
        ],
        "x": 115,
        "y": 980,
        "wires": [
            [
                "5379d0376efbcee9",
                "6ca68da351cc699c"
            ]
        ]
    },
    {
        "id": "6ca68da351cc699c",
        "type": "buffer-parser",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Trame 2",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "int32le",
                "name": "smart_sleep_voltage_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_protection_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_recovery_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_protection_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_recovery_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_trigger_voltage_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc100_voltage_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc0_voltage_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_charge_voltage_V",
                "offset": 38,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_float_voltage_V",
                "offset": 42,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_off_voltage_V",
                "offset": 46,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_charge_current_A",
                "offset": 50,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_delay_S",
                "offset": 54,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_recovery_time_S",
                "offset": 58,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_discharge_current_S",
                "offset": 62,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_delay_S",
                "offset": 66,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_recovery_time_S",
                "offset": 70,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_recovery_time_S",
                "offset": 74,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_balance_current_A",
                "offset": 78,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_T",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_recovery_T",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_T",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_recovery_T",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_T",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_recovery_T",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_T",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_recovery_T",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_count_N",
                "offset": 114,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "charging_switch_B",
                "offset": 118,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "discharging_switch_B",
                "offset": 122,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "balance_switch_B",
                "offset": 126,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "total_battery_capacity_Ah",
                "offset": 130,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_delay_S",
                "offset": 134,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_starting_voltage_V",
                "offset": 138,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Connexion_wire_resistance_1_R",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Device_address_N",
                "offset": 270,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "display_always_on_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 4,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "smart_sleep_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 7,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "disable_pcl_module_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 8,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "timed_stored_data_switch_B",
                "offset": 283,
                "length": 1,
                "offsetbit": 1,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 240,
        "y": 980,
        "wires": [
            [
                "d0b96287555baddd",
                "4716f48d98903bbc",
                "aa3df0b5914b5eef",
                "d40d5fc3b0703a4d"
            ]
        ]
    },
    {
        "id": "4716f48d98903bbc",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Setup To MQTT",
        "func": "// --- Récupération de l'adresse BMS depuis msg.bms_numero ---\nlet bmsAdresse = msg.bms_numero;\n\n// Gestion du cas où bmsAdresse est 0 (à convertir en master) ou un nombre\nlet slaveIdStr;\nif (bmsAdresse === 0) {\n    slaveIdStr = \"master\";\n} else {\n    slaveIdStr = String(bmsAdresse);\n}\n\n// --- Définition des variables de base ---\nvar payload = msg.payload;\nvar baseTopic = \"BMS_\" + slaveIdStr;\nvar discoveryPrefix = \"homeassistant\";\nvar deviceName = \"BMS_\" + slaveIdStr;\nvar deviceID = \"BMS_\" + slaveIdStr + \"_device\";\n\nvar discoveryMsgs = [];\n\n// --- Fonction de conversion des booléens ---\nfunction formatBoolean(value) {\n    if (typeof value === 'boolean') {\n        return value ? 'True' : 'False';\n    }\n    if (typeof value === 'string') {\n        const lowerVal = value.toLowerCase();\n        return lowerVal === 'true' ? 'True' : lowerVal === 'false' ? 'False' : value;\n    }\n    return value;\n}\n\n// --- Fonction de création du payload de config Home Assistant ---\nfunction createConfigPayload(key, value) {\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n    var entityType = \"number\";\n    if (key.endsWith(\"_B\")) {\n        entityType = \"switch\";\n    }\n    var configTopic = `${discoveryPrefix}/${entityType}/${deviceID}/${cleanKey}/config`;\n\n    var configPayload = {\n        name: `BMS ${key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \")}`,\n        unique_id: `${deviceID}_${cleanKey}`,\n        state_topic: `${baseTopic}/control/${cleanKey}/state`,\n        command_topic: `${baseTopic}/control/${cleanKey}/set`,\n        entity_category: \"config\",\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: payload.BMS_A || \"JK-BMS - RS485 - Ip Gateway\",\n            sw_version: \"3.3\"\n        }\n    };\n\n    if (entityType === \"number\") {\n        configPayload.mode = \"box\";\n        \n        // 🔹 Bornes personnalisées pour les champs spécifiques\n        const customBounds = {\n            max_charge_current_A: { min: 0, max: 600, step: 0.1, unit: \"A\" },\n            max_discharge_current_S: { min: 0, max: 600, step: 0.1, unit: \"A\" },\n            max_balance_current_A: { min: 0, max: 10, step: 0.1, unit: \"A\" },\n            total_battery_capacity_Ah: { min: 5, max: 2000, step: 1, unit: \"Ah\" },\n            short_circuit_protection_delay_S: { min: 0, max: 5000, step: 1, unit: \"s\" },\n            charge_overcurrent_protection_delay_S: { min: 2, max: 600, step: 1, unit: \"s\" },\n            discharge_overcurrent_protection_delay_S: { min: 2, max: 600, step: 1, unit: \"s\" },\n            charge_overcurrent_protection_recovery_time_S: { min: 2, max: 3600, step: 1, unit: \"s\" },\n            discharge_overcurrent_protection_recovery_time_S: { min: 2, max: 3600, step: 1, unit: \"s\" },\n            short_circuit_protection_recovery_time_S: { min: 2, max: 600, step: 1, unit: \"s\" },\n            smart_sleep_voltage_V: { min: 0, max: 5, step: 0.01, unit: \"V\" },\n            cell_voltage_undervoltage_protection_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n            cell_voltage_undervoltage_recovery_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n            cell_voltage_overvoltage_protection_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n            cell_voltage_overvoltage_recovery_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n            balance_trigger_voltage_V: { min: 0.003, max: 1, step: 0.001, unit: \"V\" },\n            cell_soc100_voltage_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n            cell_soc0_voltage_V: { min: 1, max: 4.5, step: 0.001, unit: \"V\" },\n            cell_request_charge_voltage_V: { min: 1.2, max: 5, step: 0.01, unit: \"V\" },\n            cell_request_float_voltage_V: { min: 1.2, max: 5, step: 0.01, unit: \"V\" },\n            power_off_voltage_V: { min: 1.2, max: 4.5, step: 0.01, unit: \"V\" },\n            balance_starting_voltage_V: { min: 1.2, max: 4.25, step: 0.01, unit: \"V\" },\n            charge_overtemperature_protection_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n            charge_overtemperature_protection_recovery_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n            discharge_overtemperature_protection_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n            discharge_overtemperature_protection_recovery_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n            charge_undertemperature_protection_T: { min: -40, max: 50, step: 0.5, unit: \"°C\" },\n            charge_undertemperature_protection_recovery_T: { min: -40, max: 50, step: 0.5, unit: \"°C\" },\n            power_tube_overtemperature_protection_T: { min: 30, max: 100, step: 0.5, unit: \"°C\" },\n            power_tube_overtemperature_protection_recovery_T: { min: 30, max: 100, step: 0.5, unit: \"°C\" },\n            cell_count_N: { min: 1, max: 32, step: 1, unit: \"\" },\n            Connexion_wire_resistance_1_R: { min: 0, max: 1000, step: 0.1, unit: \"mΩ\" },\n            Device_address_N: { min: 0, max: 247, step: 1, unit: \"\" }\n        };\n        \n        const bounds = customBounds[key];\n        if (bounds) {\n            configPayload.min = bounds.min;\n            configPayload.max = bounds.max;\n            configPayload.step = bounds.step;\n            if (bounds.unit) configPayload.unit_of_measurement = bounds.unit;\n        } else {\n            // Règles par défaut selon le suffixe\n            if (key.endsWith(\"_V\")) {\n                configPayload.unit_of_measurement = \"V\";\n                configPayload.min = 0;\n                configPayload.max = 5;\n                configPayload.step = 0.01;\n            } else if (key.endsWith(\"_A\")) {\n                configPayload.unit_of_measurement = \"A\";\n                configPayload.min = 0;\n                configPayload.max = 600;\n                configPayload.step = 0.1;\n            } else if (key.endsWith(\"_Ah\")) {\n                configPayload.unit_of_measurement = \"Ah\";\n                configPayload.min = 0;\n                configPayload.max = 2000;\n                configPayload.step = 1;\n            } else if (key.endsWith(\"_S\")) {\n                configPayload.unit_of_measurement = \"s\";\n                configPayload.min = 0;\n                configPayload.max = 5000;\n                configPayload.step = 1;\n            } else if (key.endsWith(\"_T\")) {\n                configPayload.unit_of_measurement = \"°C\";\n                configPayload.min = -40;\n                configPayload.max = 150;\n                configPayload.step = 0.5;\n            } else if (key.endsWith(\"_R\")) {\n                configPayload.unit_of_measurement = \"Ω\";\n                configPayload.min = 0;\n                configPayload.max = 1000;\n                configPayload.step = 0.1;\n            } else {\n                // 🔹 CORRECTION: augmentation de 100 à 5000\n                configPayload.min = 0;\n                configPayload.max = 5000;\n                configPayload.step = 1;\n            }\n        }\n    } else if (entityType === \"switch\") {\n        configPayload.payload_on = \"True\";\n        configPayload.payload_off = \"False\";\n        configPayload.state_on = \"True\";\n        configPayload.state_off = \"False\";\n    }\n\n    return {\n        topic: configTopic,\n        payload: JSON.stringify(configPayload),\n        retain: true\n    };\n}\n\n// --- Génération des messages de découverte et d'état ---\nfor (var key in payload) {\n    // Message de découverte Home Assistant\n    discoveryMsgs.push(createConfigPayload(key, payload[key]));\n\n    // Message d'état pour chaque entité\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n    var formattedValue = formatBoolean(payload[key]);\n    discoveryMsgs.push({\n        topic: `${baseTopic}/control/${cleanKey}/state`,\n        payload: formattedValue,\n        retain: true\n    });\n}\n\n// --- Retourne le tableau de messages MQTT ---\nreturn [discoveryMsgs];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 980,
        "wires": [
            [
                "13e4f2a13df6fe21",
                "34aa954d066715d4"
            ]
        ]
    },
    {
        "id": "13e4f2a13df6fe21",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "debug 20",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 1040,
        "wires": []
    },
    {
        "id": "34aa954d066715d4",
        "type": "mqtt out",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 760,
        "y": 980,
        "wires": []
    },
    {
        "id": "88b164ac7026be0e",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "debug 23",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 240,
        "y": 820,
        "wires": []
    },
    {
        "id": "a760f49cb3f03843",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "Broadcast-serial-Out",
        "mode": "link",
        "links": [
            "74c53c8fdd7c6f6e"
        ],
        "x": 775,
        "y": 560,
        "wires": []
    },
    {
        "id": "b28c235f729ec2af",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 620,
        "y": 520,
        "wires": [
            [
                "d2613e804a5c9e0d",
                "cdc3910800c7d95b",
                "a760f49cb3f03843"
            ],
            []
        ]
    },
    {
        "id": "d2613e804a5c9e0d",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "Broadcast-serial-Out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 520,
        "wires": []
    },
    {
        "id": "bb4281bfb6b9a0ef",
        "type": "comment",
        "z": "7eba58462314a0d7",
        "name": "Cas du BMS défini en Master Modbus RS485",
        "info": "",
        "x": 190,
        "y": 40,
        "wires": []
    },
    {
        "id": "563e3f15cff0f735",
        "type": "comment",
        "z": "7eba58462314a0d7",
        "name": "C'est lui qui demande les informations aux autres BMS. De 1 à 15",
        "info": "",
        "x": 290,
        "y": 80,
        "wires": []
    },
    {
        "id": "768cb6f2c7f68b49",
        "type": "comment",
        "z": "7eba58462314a0d7",
        "name": "Dans cette configuration, on ne peut pas changer les paramètres !!!",
        "info": "",
        "x": 300,
        "y": 120,
        "wires": []
    },
    {
        "id": "4f858553df8efd17",
        "type": "comment",
        "z": "7eba58462314a0d7",
        "name": "Car il ne peut pas y avoir 2 Master sur le bus en Modbus.",
        "info": "",
        "x": 270,
        "y": 160,
        "wires": []
    },
    {
        "id": "41542c3844b4344a",
        "type": "serial in",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "",
        "serial": "6e1abcbcc6ebb714",
        "x": 160,
        "y": 520,
        "wires": [
            [
                "24f7bb18c1109510",
                "76ddac3ef98c9d5f"
            ]
        ]
    },
    {
        "id": "cc1ee5cb46e0c0b3",
        "type": "file",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "",
        "filename": "/config/temp/broadcast-serial.txt",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 850,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "cdc3910800c7d95b",
        "type": "function",
        "z": "7eba58462314a0d7",
        "d": true,
        "g": "71ff535abf2657b3",
        "name": "debug en hexa",
        "func": "// Vérifie que le payload est un Buffer\nif (Buffer.isBuffer(msg.payload)) {\n    // Convertit chaque octet en hexadécimal sur 2 chiffres\n    msg.payload = msg.payload\n        .toString('hex')                // Convertit tout le buffer en une chaîne hexadécimale continue\n        .match(/.{1,2}/g)               // Coupe la chaîne tous les 2 caractères\n        .join(' ') + '\\n';              // Ajoute un espace entre chaque octet et un retour à la ligne\n} else if (Array.isArray(msg.payload)) {\n    // Si c'est un tableau, on le traite aussi\n    msg.payload = msg.payload\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join(' ') + '\\n';\n} else {\n    // Sinon, on ne fait rien ou on peut lever une erreur\n    msg.payload = 'Payload non reconnu\\n';\n}\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 600,
        "wires": [
            [
                "cc1ee5cb46e0c0b3"
            ]
        ]
    },
    {
        "id": "40053a1d91143e21",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "Type trames + adresse modbus",
        "func": "// Reconstructeur de trames JK-BMS + Décodeur + Association adresse Modbus\n// À placer après le nœud TCP2\n\nconst bufferKey = 'jkbms_tcp_buffer';\nconst pendingDataKey = 'jkbms_pending_data'; // Sauvegarde la DATA en attente\nlet buffer = context.get(bufferKey) || [];\nlet pendingData = context.get(pendingDataKey) || null;\n\n// Convertir msg.payload en tableau d'octets si nécessaire\nif (msg.payload) {\n    if (Buffer.isBuffer(msg.payload)) {\n        buffer.push(...Array.from(msg.payload));\n    } else if (Array.isArray(msg.payload)) {\n        buffer.push(...msg.payload);\n    } else {\n        return;\n    }\n}\n\nconst frames = [];\nlet i = 0;\n\n// Extraction des trames complètes\nwhile (i < buffer.length) {\n    let frame = null;\n    let frameLength = 0;\n    \n    // Type 1 & 2 : Trames JK-BMS (commencent par 0x55, 0xAA, 0xEB, 0x90)\n    if (i + 3 < buffer.length && \n        buffer[i] === 0x55 && \n        buffer[i+1] === 0xAA && \n        buffer[i+2] === 0xEB && \n        buffer[i+3] === 0x90) {\n        \n        frameLength = 308;\n        \n        if (i + frameLength > buffer.length) {\n            break;\n        }\n        \n        frame = buffer.slice(i, i + frameLength);\n        i += frameLength;\n    }\n    \n    // Type 3 : Requêtes de commande (commencent par 0x01-0x0F, puis 0x10, 0x16)\n    else if (i + 2 < buffer.length &&\n             buffer[i] >= 0x01 && \n             buffer[i] <= 0x0F && \n             buffer[i+1] === 0x10 && \n             buffer[i+2] === 0x16) {\n        \n        frameLength = 11;\n        \n        if (i + frameLength > buffer.length) {\n            break;\n        }\n        \n        frame = buffer.slice(i, i + frameLength);\n        i += frameLength;\n    }\n    \n    else {\n        i++;\n        continue;\n    }\n    \n    if (frame && frame.length > 0) {\n        frames.push(frame);\n    }\n}\n\ncontext.set(bufferKey, buffer.slice(i));\n\n// Fonction de décodage du type de trame\nfunction typeTrame(byte) {\n    if (byte === 1) return \"setup\";\n    if (byte === 2) return \"data\";\n    return \"autre\";\n}\n\n// Traiter et envoyer les trames extraites\nconst outputFrames = [];\n\nfor (let frame of frames) {\n    // Cas 1 : Trame JK-BMS (master/broadcast)\n    if (frame[0] === 0x55 && frame[1] === 0xAA && frame[2] === 0xEB && frame[3] === 0x90) {\n        const frameType = typeTrame(frame[4]);\n        \n        if (frameType === \"data\") {\n            // **Sauvegarder la DATA en attente de la SETUP qui suit**\n            pendingData = {\n                payload: Buffer.from(frame),\n                bms_adresse: \"master\",\n                bms_type: \"data\",\n                _frameSource: \"JK-BMS\",\n                _frameLength: frame.length\n            };\n            context.set(pendingDataKey, pendingData);\n        }\n        else if (frameType === \"setup\") {\n            // **SETUP arrive → extraire le numéro à offset 270**\n            if (frame.length > 273) {\n                const bmsNumber = frame[270] | \n                                 (frame[271] << 8) | \n                                 (frame[272] << 16) | \n                                 (frame[273] << 24);\n                \n                // **Envoyer d'abord la DATA sauvegardée avec le bon numéro**\n                if (pendingData) {\n                    pendingData.bms_numero = bmsNumber;\n                    outputFrames.push(pendingData);\n                    pendingData = null;\n                    context.set(pendingDataKey, null);\n                }\n                \n                // **Puis envoyer la SETUP**\n                let setupMsg = {\n                    payload: Buffer.from(frame),\n                    bms_adresse: \"master\",\n                    bms_type: \"setup\",\n                    bms_numero: bmsNumber,\n                    _frameSource: \"JK-BMS\",\n                    _frameLength: frame.length\n                };\n                outputFrames.push(setupMsg);\n            }\n        }\n    }\n    \n    // Cas 2 : Trame de requête courte\n    else if (frame[0] >= 0x01 && frame[0] <= 0x0F && frame[1] === 0x10 && frame[2] === 0x16) {\n        let reqMsg = {\n            payload: Buffer.from(frame),\n            bms_adresse: frame[0],\n            bms_type: typeTrame(frame[15]),\n            _frameSource: \"REQUETE\",\n            _frameLength: frame.length\n        };\n        outputFrames.push(reqMsg);\n    }\n}\n\n// **Envoyer les frames traitées**\nfor (let outMsg of outputFrames) {\n    if (outMsg.bms_adresse !== undefined) {\n        node.send(outMsg);\n    }\n}\n\n// Sécurité\nif (buffer.length > 1000) {\n    node.warn(`Buffer too large (${buffer.length} bytes), clearing`);\n    context.set(bufferKey, []);\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 780,
        "wires": [
            [
                "06b6d386a10741c2",
                "9bf8da3dfdb70216",
                "326f26989b977e21"
            ]
        ]
    },
    {
        "id": "06b6d386a10741c2",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": " Types de trames analysées",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 500,
        "y": 860,
        "wires": []
    },
    {
        "id": "9bf8da3dfdb70216",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "Trame type ?",
        "property": "bms_type",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "setup",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "data",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "autre",
                "vt": "str"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 3,
        "x": 770,
        "y": 780,
        "wires": [
            [
                "a65a870d600bb230"
            ],
            [
                "1bb4998cb85dda4e"
            ],
            [
                "c467a4170735f112"
            ]
        ]
    },
    {
        "id": "54f13db307ef04c6",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "TCP debug ",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 360,
        "wires": []
    },
    {
        "id": "44c1946af35b4bf2",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "Broadcast-Out",
        "mode": "link",
        "links": [
            "74c53c8fdd7c6f6e"
        ],
        "x": 1155,
        "y": 400,
        "wires": []
    },
    {
        "id": "ac5e2007494e8ec7",
        "type": "inject",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "GW IP close",
        "props": [
            {
                "p": "action",
                "v": "close",
                "vt": "str"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 690,
        "y": 400,
        "wires": [
            [
                "39deea4e80f940dc"
            ]
        ]
    },
    {
        "id": "39deea4e80f940dc",
        "type": "tcp-client",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "action": "action",
        "actionType": "msg",
        "host": "host",
        "hostType": "msg",
        "port": "port",
        "portType": "msg",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "write": "payload",
        "writeType": "msg",
        "maxRetries": "5",
        "retryDelay": "3000",
        "indefiniteRetries": false,
        "topic": "",
        "name": "",
        "debug": "warning",
        "x": 860,
        "y": 360,
        "wires": [
            [
                "54f13db307ef04c6",
                "7c34c27efa97726a",
                "44c1946af35b4bf2"
            ]
        ]
    },
    {
        "id": "36740c8949df9213",
        "type": "change",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "GW IP Connect",
        "rules": [
            {
                "t": "set",
                "p": "action",
                "pt": "msg",
                "to": "connect",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "host",
                "pt": "msg",
                "to": "gateway_ip",
                "tot": "global"
            },
            {
                "t": "set",
                "p": "port",
                "pt": "msg",
                "to": "gateway_port",
                "tot": "global"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 680,
        "y": 360,
        "wires": [
            [
                "39deea4e80f940dc"
            ]
        ]
    },
    {
        "id": "9065a93867dab80e",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 280,
        "y": 400,
        "wires": [
            [
                "73d8b350243362a9"
            ],
            []
        ]
    },
    {
        "id": "73d8b350243362a9",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 480,
        "y": 400,
        "wires": [
            [
                "36740c8949df9213"
            ],
            []
        ]
    },
    {
        "id": "312ad2b56727f9b0",
        "type": "inject",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "3",
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 110,
        "y": 360,
        "wires": [
            [
                "69b1ce57af6c5821"
            ]
        ]
    },
    {
        "id": "69b1ce57af6c5821",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 270,
        "y": 360,
        "wires": [
            [],
            [
                "9065a93867dab80e"
            ]
        ]
    },
    {
        "id": "76ddac3ef98c9d5f",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 390,
        "y": 520,
        "wires": [
            [],
            [
                "b28c235f729ec2af"
            ]
        ]
    },
    {
        "id": "7bdc72b0af93d76a",
        "type": "inject",
        "z": "7eba58462314a0d7",
        "g": "2a96ca484e0815bf",
        "name": "Init",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 710,
        "y": 100,
        "wires": [
            [
                "b47fc264732cec08"
            ]
        ]
    },
    {
        "id": "b47fc264732cec08",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "2a96ca484e0815bf",
        "name": "Init flags for discovery",
        "func": "// Récupère le nombre total de JKBMS\nlet nb = global.get(\"nb_jkbms\") || 1;\n\n//-----------------------------------------------\n// RESET EXISTANT (ne pas toucher)\n//-----------------------------------------------\n\n// Toujours remettre le Master à false (partie originale)\nflow.set(\"discoverySent_BMS_master\", false);\n\n// Chaque BMS secondaire (partie originale)\nfor (let i = 1; i <= nb; i++) {\n    let key = `discoverySent_BMS_${i}`;\n    flow.set(key, false);\n}\n\n//-----------------------------------------------\n// ➕ AJOUT : RESET DES DISCOVERY D’ALARMES\n//-----------------------------------------------\n\n// Reset du Master (nouveau)\nflow.set(\"discoverySent_ALARMS_BMS_master\", false);\n\n// Reset de chaque BMS secondaire (nouveau)\nfor (let i = 1; i <= nb; i++) {\n    let alarmKey = `discoverySent_ALARMS_BMS_${i}`;\n    flow.set(alarmKey, false);\n}\n\n// Reset du discovery global des alarmes (nouveau)\nflow.set(\"discoverySent_GLOBAL_ALARM\", false);\n\n//-----------------------------------------------\n\nnode.warn(`Discovery reset done for Master + ${nb} BMS (incl. alarms).`);\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "eb4d973c278afdbc",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "debug-out",
        "mode": "link",
        "links": [
            "4c96f83e2c664c74"
        ],
        "x": 195,
        "y": 860,
        "wires": []
    },
    {
        "id": "01565a6abef1f0a8",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Debug-data-in",
        "mode": "link",
        "links": [
            "8eea8a8ef9220c22"
        ],
        "x": 205,
        "y": 1280,
        "wires": []
    },
    {
        "id": "aa3df0b5914b5eef",
        "type": "function",
        "z": "7eba58462314a0d7",
        "d": true,
        "g": "a1697c874f4c5e2d",
        "name": "BMS-Nb",
        "func": "var BMS = msg.payload[\"Device_address_N\"];\n// Pour debug, affichons la valeur BMS\nnode.warn(`BMS Nb:${BMS} is alive`);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 980,
        "wires": [
            []
        ]
    },
    {
        "id": "7d85cec3b8e788bf",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "a3a21b2242312efd",
        "name": "Gestion des alarmes (32 bits)",
        "func": "const errorList = [\n    \"Balancing resistance too high\",               // bit 0\n    \"MOS over-temperature protection\",             // bit 1\n    \"Number of cells does not match parameter\",    // bit 2\n    \"Abnormal current sensor\",                     // bit 3\n    \"Cell over-voltage protection\",                // bit 4\n    \"Battery over-voltage protection\",             // bit 5\n    \"Overcurrent charge protection\",               // bit 6\n    \"Charge short-circuit protection\",             // bit 7\n    \"Over-temperature charge protection\",          // bit 8\n    \"Low temperature charge protection\",           // bit 9\n    \"Internal communication anomaly\",              // bit 10\n    \"Cell under-voltage protection\",               // bit 11\n    \"Battery under-voltage protection\",            // bit 12\n    \"Overcurrent discharge protection\",            // bit 13\n    \"Discharge short-circuit protection\",          // bit 14\n    \"Over-temperature discharge protection\",       // bit 15\n    \"Charge MOS anomaly\",                          // bit 16\n    \"Discharge MOS anomaly\",                       // bit 17\n    \"GPS disconnected\",                            // bit 18\n    \"Please modify the authorization password in time\", // bit 19\n    \"Discharge activation failure\",                // bit 20\n    \"Battery over-temperature alarm\",              // bit 21\n    \"Temperature sensor anomaly\",                  // bit 22\n    \"Parallel module anomaly\",                     // bit 23\n    \"Erreur fictive Bit 24\",\n    \"Erreur fictive Bit 25\",\n    \"Erreur fictive Bit 26\",\n    \"Erreur fictive Bit 27\",\n    \"Erreur fictive Bit 28\",\n    \"Erreur fictive Bit 29\",\n    \"Erreur fictive Bit 30\",\n    \"Erreur fictive Bit 31\"\n];\n\nconst buffer = msg.payload;\nif (buffer.length <= 169) {\n    msg.payload = { error: \"Buffer too small to extract error code\", bms_address: msg.bms_adresse };\n    return msg;\n}\n\n// Swap bytes as requested\nconst swappedErrorCode =\n    (buffer[169] << 24) |\n    (buffer[168] << 16) |\n    (buffer[167] << 8) |\n    (buffer[166]);\n\nconst activeErrors = [];\nfor (let i = 0; i < errorList.length; i++) {\n    if (swappedErrorCode & (1 << i)) {\n        activeErrors.push(errorList[i]);\n    }\n}\n\n// Construction du payload dans le format \"référence\"\n// MODIFICATION: Ne pas inclure le préfixe \"🚨 BMS Alarm Alert\" dans le tableau errors\nmsg.payload = {\n    bms_address: msg.bms_numero,\n    error_code: swappedErrorCode,\n    errors: activeErrors.length > 0 ? activeErrors : []\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 1420,
        "wires": [
            [
                "c61f13fa51886e67",
                "4718ccede024f711"
            ]
        ]
    },
    {
        "id": "c61f13fa51886e67",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a3a21b2242312efd",
        "name": "New version",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 150,
        "y": 1480,
        "wires": []
    },
    {
        "id": "582e23a67b8ce434",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a3a21b2242312efd",
        "name": "debug 5",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 1420,
        "wires": []
    },
    {
        "id": "4718ccede024f711",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "a3a21b2242312efd",
        "name": "TRAITEMENT DES ALARMES",
        "func": "// ====== TRAITEMENT DES ALARMES (NOUVEAU PAYLOAD) - version 2 sorties ======\n\nconst p = msg.payload;\n\n// ------------------------------------------------------------------\n// VALIDATION\nif (!p || typeof p.error_code !== \"number\") {\n    node.error(\"Invalid payload: error_code missing\");\n    return null;\n}\n\nif (typeof msg.bms_numero !== \"number\") {\n    node.error(\"Invalid message: bms_numero missing or not a number\");\n    return null;\n}\n\n// ------------------------------------------------------------------\n// DÉTERMINATION DU BMS (master / esclave)\nlet bmsName;\nlet bmsId;\n\nif (msg.bms_numero === 0) {\n    // BMS master\n    bmsName = \"BMS_master\";\n    bmsId = 0;\n} else {\n    // BMS esclave\n    bmsId = msg.bms_numero;\n    bmsName = `BMS_${bmsId}`;\n}\n\n// ------------------------------------------------------------------\n// CONVERSION AU FORMAT INTERNE\nconst hasAlarms = p.error_code !== 0;\nconst alarmCount = (p.errors && hasAlarms) ? p.errors.length : 0;\n\nconst alarmData = {\n    bms_id: bmsId,\n    has_alarms: hasAlarms,\n    alarm_count: alarmCount,\n    active_alarms: (p.errors && hasAlarms)\n        ? p.errors.map(e => ({ description: e }))\n        : [],\n    alarm_details: {\n        status: hasAlarms\n            ? \"🚨 BMS Alarm Alert\"\n            : \"No BMS alarms\"\n    }\n};\n\n// Mise à disposition pour les nœuds suivants\nmsg.alarms = alarmData;\nmsg.bms_name = bmsName;\nmsg.bms_id = bmsId;\n\n// ------------------------------------------------------------------\n// DISCOVERY / MQTT\nconst discoveryKey = `discoverySent_ALARMS_${bmsName}`;\nconst discoveryAlreadySent = flow.get(discoveryKey) || false;\n\nconst baseTopic = bmsName;\nconst discoveryPrefix = \"homeassistant\";\nconst deviceID = `${bmsName}_device`;\n\n// ------------------------------------------------------------------\nfunction buildDiscovery() {\n    const m = [];\n\n    m.push({\n        topic: `${discoveryPrefix}/binary_sensor/${deviceID}/alarm_active/config`,\n        payload: {\n            name: `${bmsName} Alarm Active`,\n            unique_id: `${deviceID}_alarm_active`,\n            state_topic: `${baseTopic}/alarm/active`,\n            payload_on: \"ON\",\n            payload_off: \"OFF\",\n            device_class: \"problem\",\n            icon: \"mdi:alert-circle\",\n            device: {\n                identifiers: [deviceID],\n                name: bmsName\n            }\n        },\n        retain: true\n    });\n\n    m.push({\n        topic: `${discoveryPrefix}/sensor/${deviceID}/visual_status/config`,\n        payload: {\n            name: `${bmsName} Visual Status`,\n            unique_id: `${deviceID}_visual_status`,\n            state_topic: `${baseTopic}/alarm/visual_status`,\n            icon: \"mdi:gauge\",\n            device: {\n                identifiers: [deviceID],\n                name: bmsName\n            }\n        },\n        retain: true\n    });\n\n    m.push({\n        topic: `${discoveryPrefix}/sensor/${deviceID}/alarm_status/config`,\n        payload: {\n            name: `${bmsName} Alarm Status`,\n            unique_id: `${deviceID}_alarm_status`,\n            state_topic: `${baseTopic}/alarm/status`,\n            icon: \"mdi:text-box-outline\",\n            device: {\n                identifiers: [deviceID],\n                name: bmsName\n            }\n        },\n        retain: true\n    });\n\n    m.push({\n        topic: `${discoveryPrefix}/sensor/${deviceID}/alarm_list/config`,\n        payload: {\n            name: `${bmsName} Alarm List`,\n            unique_id: `${deviceID}_alarm_list`,\n            state_topic: `${baseTopic}/alarm/list`,\n            icon: \"mdi:format-list-bulleted\",\n            device: {\n                identifiers: [deviceID],\n                name: bmsName\n            }\n        },\n        retain: true\n    });\n\n    return m;\n}\n\n// ------------------------------------------------------------------\nfunction buildState() {\n    const out = [];\n\n    out.push({\n        topic: `${baseTopic}/alarm/active`,\n        payload: alarmData.has_alarms ? \"ON\" : \"OFF\",\n        retain: true\n    });\n\n    out.push({\n        topic: `${baseTopic}/alarm/visual_status`,\n        payload: alarmData.has_alarms\n            ? `🚨 ${alarmData.alarm_count} alarme(s)`\n            : \"✅ No alarm\",\n        retain: true\n    });\n\n    out.push({\n        topic: `${baseTopic}/alarm/status`,\n        payload: alarmData.alarm_details.status,\n        retain: true\n    });\n\n    out.push({\n        topic: `${baseTopic}/alarm/list`,\n        payload: alarmData.active_alarms.length > 0\n            ? alarmData.active_alarms.map(a => a.description).join(\", \")\n            : \"No alarms\",\n        retain: true\n    });\n\n    return out;\n}\n\n// ------------------------------------------------------------------\n// PRÉPARATION DES SORTIES\nconst mqttMsgs = [];\n\nif (!discoveryAlreadySent) {\n    mqttMsgs.push(...buildDiscovery());\n    flow.set(discoveryKey, true);\n}\n\nmqttMsgs.push(...buildState());\n\n// ------------------------------------------------------------------\n// SORTIES\n// sortie 1 = messages MQTT\n// sortie 2 = msg enrichi (msg.alarms, msg.bms_name, msg.bms_id)\nreturn [ mqttMsgs, msg ];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 1420,
        "wires": [
            [
                "582e23a67b8ce434",
                "c9cbac907c0d0ae7"
            ],
            [
                "92b1d01fa81c4af0"
            ]
        ],
        "outputLabels": [
            "mqtt",
            "alarmes"
        ]
    },
    {
        "id": "568cf4c923b7c5bd",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "a3a21b2242312efd",
        "name": "AGRÉGATION GLOBALE",
        "func": "// ===== AGRÉGATION GLOBALE DES ALARMES (OPTION B ROBUSTE) =====\n\nconst alarmData = msg.alarms;\n\nif (!alarmData || alarmData.bms_id === undefined || alarmData.bms_id === null) {\n    return null;\n}\n\nconst bmsId = alarmData.bms_id;\nconst now = Date.now();\n\n// Nombre de BMS esclaves (hors master)\nconst TOTAL_BMS = global.get(\"nb_jkbms\") || 4;\n\n// Durée max (ms) sans message avant exclusion du calcul\nconst TIMEOUT_MS = 15000;\n\n// Enregistrement état + timestamp\nflow.set(`bms_alarm_state_${bmsId}`, {\n    has_alarm: alarmData.has_alarms,\n    alarm_count: alarmData.alarm_count,\n    last_seen: now\n});\n\n// Calcul état global\nlet globalHas = false;\n\nfor (let i = 0; i <= TOTAL_BMS; i++) {\n    const s = flow.get(`bms_alarm_state_${i}`);\n    if (!s) continue;\n\n    // Ignore BMS muet depuis trop longtemps\n    if ((now - s.last_seen) > TIMEOUT_MS) continue;\n\n    if (s.has_alarm) {\n        globalHas = true;\n        break;\n    }\n}\n\n// MQTT / HA\nconst discoveryPrefix = \"homeassistant\";\nconst globalDeviceID = \"BMS_GLOBAL_device\";\nconst messages = [];\n\n// Discovery (une fois)\nif (!flow.get(\"discoverySent_GLOBAL_ALARM\")) {\n    messages.push({\n        topic: `${discoveryPrefix}/binary_sensor/${globalDeviceID}/alarm_active/config`,\n        payload: {\n            name: \"BMS Global Alarm\",\n            unique_id: `${globalDeviceID}_alarm_active`,\n            state_topic: \"BMS_GLOBAL/alarm/state\",\n            payload_on: \"ON\",\n            payload_off: \"OFF\",\n            device_class: \"problem\",\n            icon: \"mdi:battery-alert\",\n            device: {\n                identifiers: [globalDeviceID],\n                name: \"BMS Global\"\n            }\n        },\n        retain: true\n    });\n\n    flow.set(\"discoverySent_GLOBAL_ALARM\", true);\n}\n// node.warn(flow.get(`bms_alarm_state_1`));\n\n// Publication état global\nmessages.push({\n    topic: \"BMS_GLOBAL/alarm/state\",\n    payload: globalHas ? \"ON\" : \"OFF\",\n    retain: true\n});\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 1480,
        "wires": [
            [
                "3f01427254d074d7",
                "aeb356a830532d6c"
            ]
        ]
    },
    {
        "id": "3f01427254d074d7",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a3a21b2242312efd",
        "name": "debug 9",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 1480,
        "wires": []
    },
    {
        "id": "c9cbac907c0d0ae7",
        "type": "mqtt out",
        "z": "7eba58462314a0d7",
        "g": "a3a21b2242312efd",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 800,
        "y": 1420,
        "wires": []
    },
    {
        "id": "aeb356a830532d6c",
        "type": "mqtt out",
        "z": "7eba58462314a0d7",
        "g": "a3a21b2242312efd",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 800,
        "y": 1480,
        "wires": []
    },
    {
        "id": "92b1d01fa81c4af0",
        "type": "delay",
        "z": "7eba58462314a0d7",
        "g": "a3a21b2242312efd",
        "name": "",
        "pauseType": "delay",
        "timeout": "100",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 350,
        "y": 1480,
        "wires": [
            [
                "568cf4c923b7c5bd"
            ]
        ]
    },
    {
        "id": "17af908365d66c64",
        "type": "file",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "",
        "filename": "/config/temp/broadcast-tcp2.txt",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1130,
        "y": 300,
        "wires": [
            []
        ]
    },
    {
        "id": "7c34c27efa97726a",
        "type": "function",
        "z": "7eba58462314a0d7",
        "d": true,
        "g": "8db7330998795c6b",
        "name": "debug en hexa",
        "func": "// Vérifie que le payload est un Buffer\nif (Buffer.isBuffer(msg.payload)) {\n    // Convertit chaque octet en hexadécimal sur 2 chiffres\n    msg.payload = msg.payload\n        .toString('hex')                // Convertit tout le buffer en une chaîne hexadécimale continue\n        .match(/.{1,2}/g)               // Coupe la chaîne tous les 2 caractères\n        .join(' ') + '\\n';              // Ajoute un espace entre chaque octet et un retour à la ligne\n} else if (Array.isArray(msg.payload)) {\n    // Si c'est un tableau, on le traite aussi\n    msg.payload = msg.payload\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join(' ') + '\\n';\n} else {\n    // Sinon, on ne fait rien ou on peut lever une erreur\n    msg.payload = 'Payload non reconnu\\n';\n}\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 320,
        "wires": [
            [
                "17af908365d66c64"
            ]
        ]
    },
    {
        "id": "326f26989b977e21",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "bms_adresse",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "bms_adresse",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 820,
        "wires": []
    },
    {
        "id": "c467a4170735f112",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "adresse dans trame",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "bms_adresse",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 860,
        "wires": []
    },
    {
        "id": "62299fe8aa268603",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "adresse dans trame",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "bms_numero",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 480,
        "y": 1280,
        "wires": []
    },
    {
        "id": "d40d5fc3b0703a4d",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "adresse dans trame",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "bms_numero",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 480,
        "y": 1060,
        "wires": []
    },
    {
        "id": "db723bbce9cd2eb7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "Autre",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 150,
        "y": 1120,
        "wires": []
    },
    {
        "id": "c3de74fe6e67e34d",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "command": "candump can0",
        "addpay": "",
        "append": "",
        "useSpawn": "true",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "CANdump",
        "x": 310,
        "y": 420,
        "wires": [
            [
                "0efe20eac7430343"
            ],
            [
                "b1930c0f7c133e97"
            ],
            []
        ]
    },
    {
        "id": "3228a87076560c09",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 420,
        "wires": [
            [
                "c3de74fe6e67e34d"
            ]
        ]
    },
    {
        "id": "b1930c0f7c133e97",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "CAN dump",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 510,
        "y": 460,
        "wires": []
    },
    {
        "id": "0efe20eac7430343",
        "type": "rbe",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 490,
        "y": 420,
        "wires": [
            [
                "a382ef9233e091ce",
                "f42caadb5356ae1d"
            ]
        ]
    },
    {
        "id": "edddd5764795e5e8",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "CAN décodées",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 460,
        "wires": []
    },
    {
        "id": "a382ef9233e091ce",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "Décodage protocole 6 - 500000 bds",
        "func": "// === Décodage trames CAN JKBMS - Dernière mise à jour ===\n\nfunction parseCanFrame(payload) {\n    const regex = /can0\\s+([A-F0-9]+)\\s+\\[8\\]\\s+([A-F0-9\\s]+)/;\n    const match = payload.match(regex);\n    if (!match) return null;\n    const canId = match[1];\n    const dataHex = match[2].trim().split(/\\s+/);\n    const data = dataHex.map(hex => parseInt(hex, 16));\n    return { canId, data };\n}\n\nfunction decode2F4(data) {\n    const totalVoltage = ((data[1] << 8) | data[0]) * 0.1;\n    const soc = data[4];\n    let rawCurrent = (data[3] << 8) | data[2];\n    if (rawCurrent > 32767) rawCurrent -= 65536;\n    const current = (rawCurrent * 0.1) - 400;\n    return {\n        type: \"main_status\",\n        totalVoltage,\n        soc,\n        current\n    };\n}\n\nfunction decode07F4(data) {\n    let alarmBits = 0;\n    for (let i = 0; i < 4; i++) {\n        alarmBits |= data[i] << (8 * i);\n    }\n    const alarmList = [\n        \"Cell overvoltage\",\n        \"Cell undervoltage\",\n        \"Total voltage overvoltage\",\n        \"Total voltage undervoltage\",\n        \"Large pressure difference of monomer\",\n        \"Discharge overcurrent\",\n        \"Charge overcurrent\",\n        \"Temperature is too high\",\n        \"Temperature is too low\",\n        \"Excessive temperature difference\",\n        \"SOC too low\",\n        \"Insulation is too low\",\n        \"High voltage interlock fault\",\n        \"External communication failure\",\n        \"Internal communication failure\"\n    ];\n    const alarms = [];\n    for (let i = 0; i < alarmList.length; i++) {\n        const level = (alarmBits >> (i * 2)) & 0x03;\n        if (level > 0) {\n            alarms.push({\n                code: i + 1,\n                name: alarmList[i],\n                level,\n                levelText: [\"\", \"Serious\", \"Important\", \"General\"][level]\n            });\n        }\n    }\n    return {\n        type: \"alarm_info\",\n        alarms,\n        alarmCount: alarms.length,\n        rawAlarmBits: alarmBits\n    };\n}\n\nfunction decode4F4(data) {\n    const deltaCellVoltage = data[0] * 0.001;\n    const maxCellVoltage = ((data[1] << 8) | data[0]) * 0.001;\n    const maxCellPosition = data[2];\n    const minCellVoltage = ((data[4] << 8) | data[3]) * 0.001;\n    const minCellPosition = data[5];\n    return {\n        type: \"cell_minmax\",\n        deltaCellVoltage,\n        maxCellVoltage,\n        maxCellPosition,\n        minCellVoltage,\n        minCellPosition\n    };\n}\n\nfunction decode5F4(data) {\n    const maxTemp = data[0] - 50;\n    const maxTempPosition = data[1];\n    const minTemp = data[2] - 50;\n    const minTempPosition = data[3];\n    const avgTemp = data[4] - 50;\n    return {\n        type: \"temperatures\",\n        maxTemp,\n        maxTempPosition,\n        minTemp,\n        minTempPosition,\n        avgTemp\n    };\n}\n\nfunction decode18F128F4(data) {\n    let current = (data[1] << 8) | data[0];\n    if (current > 32767) current -= 65536;\n    current *= 0.001;\n    const power = ((data[3] << 8) | data[2]) * 0.1;\n    const cycleCount = (data[7] << 8) | data[6];\n    return {\n        type: \"power_current\",\n        current,\n        power,\n        cycleCount\n    };\n}\n\n// ✅ MISE À JOUR : ID 01F21400\nfunction decode01F21400(data) {\n    // Byte 0–1 : Voltage (unsigned), × 0.01\n    const voltage = ((data[1] << 8) | data[0]) * 0.01;\n\n    // Byte 2–3 : Current (signed), × 0.1\n    let rawCurrent = (data[3] << 8) | data[2];\n    if (rawCurrent > 32767) rawCurrent -= 65536;\n    const current = rawCurrent * 0.1;\n\n    // Byte 4–5 : Temperature (signed), ÷ 10\n    let rawTemp = (data[5] << 8) | data[4];\n    if (rawTemp > 32767) rawTemp -= 65536;\n    const temperature = rawTemp / 10;\n\n    // Byte 6–7 : Cycle count (unsigned)\n    const cycleCount = (data[7] << 8) | data[6];\n\n    return {\n        type: \"monitoring\",\n        voltage,       // en V\n        current,       // en A\n        temperature,   // en °C\n        cycleCount\n    };\n}\n\nfunction decode18F528F4(data) {\n    const alarmCode = data[0];\n    const cycleCount = (data[2] << 8) | data[1];\n    const alarmMap = {\n        0: \"Normal\",\n        1: \"Cell overvoltage\",\n        2: \"Cell undervoltage\",\n        3: \"Pack overvoltage\",\n        4: \"Pack undervoltage\",\n        5: \"Charge overcurrent\",\n        6: \"Discharge overcurrent\",\n        7: \"Charge overtemp\",\n        8: \"Discharge overtemp\",\n        9: \"Charge undertemp\",\n        10: \"Discharge undertemp\",\n        11: \"MOS overtemp\",\n        12: \"Short circuit\",\n        13: \"BMS overtemp\",\n        14: \"BMS undertemp\",\n        23: \"Cell imbalance\",\n        35: \"System normal\"\n    };\n    return {\n        type: \"cycle_count\",\n        alarmCode,\n        alarmText: alarmMap[alarmCode] || `Unknown alarm ${alarmCode}`,\n        cycleCount\n    };\n}\n\nfunction decode1806E5F4(data) {\n    const value = (data[3] << 8) | data[2];\n    return {\n        type: \"status_data\",\n        value,\n        byte0: data[0],\n        byte1: data[1],\n        rawBytes: data\n    };\n}\n\nfunction decode18F228F4(data) {\n    const temps = [];\n    let mosTemp = null;\n    for (let i = 1; i < 6; i++) {\n        if (data[i] !== 0) {\n            const temp = data[i] - 50;\n            temps.push(temp);\n        }\n    }\n    if (temps.length > 0) {\n        mosTemp = temps[0];\n    }\n    return {\n        type: \"individual_temps\",\n        temperatures: temps,\n        mosTemp,\n        sensorCount: temps.length,\n        byte0: data[0]\n    };\n}\n\nfunction decode18F428F4(data) {\n    const systemData = (data[1] << 8) | data[0];\n    const socAlt = data[6];\n    return {\n        type: \"alt_soc_data\",\n        systemData,\n        socAlt,\n        byte2: data[2],\n        rawBytes: data\n    };\n}\n\nfunction decodeCellVoltages(canId, data) {\n    const baseId = parseInt(canId.substring(3, 4));\n    const cellStart = baseId * 4;\n    const voltages = [];\n    for (let i = 0; i < 8; i += 2) {\n        const voltage = ((data[i + 1] << 8) | data[i]) * 0.001;\n        voltages.push({\n            cellNumber: cellStart + (i / 2) + 1,\n            voltage\n        });\n    }\n    return {\n        type: \"cell_voltages\",\n        group: baseId,\n        voltages\n    };\n}\n\nfunction decodeExperimental(canId, data) {\n    const patterns = [];\n    for (let i = 0; i < data.length; i++) {\n        if (data[i] >= 70 && data[i] <= 80) {\n            patterns.push({\n                type: \"possible_mos_temp\",\n                position: i,\n                value: data[i] - 50,\n                rawValue: data[i]\n            });\n        }\n    }\n    for (let i = 0; i < data.length - 1; i++) {\n        const value16 = (data[i + 1] << 8) | data[i];\n        if (value16 >= 10 && value16 <= 50) {\n            patterns.push({\n                type: \"possible_cycle_count\",\n                position: i,\n                value: value16,\n                rawBytes: [data[i], data[i + 1]]\n            });\n        }\n    }\n    return {\n        type: \"experimental\",\n        canId,\n        patterns,\n        rawData: data\n    };\n}\n\n// === LOGIQUE PRINCIPALE ===\nconst parsed = parseCanFrame(msg.payload);\nif (!parsed) {\n    return {\n        payload: {\n            timestamp: new Date().toISOString(),\n            canId: \"\",\n            type: \"parse_error\",\n            note: \"Erreur parsing trame CAN\"\n        }\n    };\n}\n\nconst { canId, data } = parsed;\nlet decoded;\n\nswitch (canId) {\n    case \"2F4\":\n        decoded = decode2F4(data);\n        break;\n    case \"4F4\":\n        decoded = decode4F4(data);\n        break;\n    case \"5F4\":\n        decoded = decode5F4(data);\n        break;\n    case \"7F4\":\n        decoded = decode07F4(data);\n        break;\n    case \"18F128F4\":\n        decoded = decode18F128F4(data);\n        break;\n    case \"01F21400\":\n        decoded = decode01F21400(data);\n        break;\n    case \"18F528F4\":\n        decoded = decode18F528F4(data);\n        break;\n    case \"1806E5F4\":\n        decoded = decode1806E5F4(data);\n        break;\n    case \"18F228F4\":\n        decoded = decode18F228F4(data);\n        break;\n    case \"18F428F4\":\n        decoded = decode18F428F4(data);\n        break;\n    default:\n        if (canId.match(/^18E[0-3]28F4$/)) {\n            decoded = decodeCellVoltages(canId, data);\n        } else {\n            decoded = decodeExperimental(canId, data);\n        }\n        break;\n}\n\nlet bmsId = \"unknown\";\nif (decoded.type === \"cycle_count\") {\n    bmsId = decoded.cycleCount === 35 ? \"BMS2\" : \"BMS1\";\n} else if (decoded.type === \"power_current\" && typeof decoded.cycleCount !== \"undefined\") {\n    bmsId = decoded.cycleCount === 35 ? \"BMS2\" : (decoded.cycleCount === 12 ? \"BMS1\" : \"unknown\");\n} else if (decoded.type === \"individual_temps\" && typeof decoded.mosTemp === \"number\") {\n    bmsId = decoded.mosTemp > 24 ? \"BMS2\" : \"BMS1\";\n}\n\nreturn {\n    payload: {\n        timestamp: new Date().toISOString(),\n        canId,\n        bmsId,\n        rawData: data,\n        rawHex: data.map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' '),\n        ...decoded\n    }\n};\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 420,
        "wires": [
            [
                "edddd5764795e5e8",
                "3468acfdfe712e73"
            ]
        ]
    },
    {
        "id": "427020bec4bb2db0",
        "type": "switch",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "property": "payload.canId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "2F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "4F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "5F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "7F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "01F21400",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "1806E5F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E028F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E128F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E228F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E328F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F128F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F228F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F328F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F428F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F528F4",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 16,
        "x": 120,
        "y": 900,
        "wires": [
            [
                "21eb77fc0deb7df8"
            ],
            [
                "91aacf4dfc2f6b45"
            ],
            [
                "8144d8148f4c0840"
            ],
            [
                "1daa9e6390671ea8"
            ],
            [
                "72b36b4609b42dba"
            ],
            [
                "b84f87970c11f14e"
            ],
            [
                "7d97f7131d3497a0"
            ],
            [
                "32e8d6abd9ac44d0"
            ],
            [
                "740e7dc1d40c5efa"
            ],
            [
                "4be4303ae0f078dc"
            ],
            [
                "2a10c4fd52fdcdbf"
            ],
            [
                "0005b67220843057"
            ],
            [
                "f28c4eb22257478c"
            ],
            [
                "c2369537eb2295bb"
            ],
            [
                "cf375bcb018ce6c2"
            ],
            [
                "db723bbce9cd2eb7"
            ]
        ]
    },
    {
        "id": "cf375bcb018ce6c2",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F528F4 - ? compteur ??",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 380,
        "y": 1260,
        "wires": []
    },
    {
        "id": "c2369537eb2295bb",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F428F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 1220,
        "wires": []
    },
    {
        "id": "f42caadb5356ae1d",
        "type": "file",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "d03facb97e5d14d1",
        "name": "",
        "filename": "/config/temp/CAN-dump.txt",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 720,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "2a10c4fd52fdcdbf",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F128F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 1060,
        "wires": []
    },
    {
        "id": "f28c4eb22257478c",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F328F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 1180,
        "wires": []
    },
    {
        "id": "b84f87970c11f14e",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "1806E5F4 - status_data",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 370,
        "y": 780,
        "wires": []
    },
    {
        "id": "e7576279e8153b1b",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "totalVoltage - soc -current",
        "func": "// Récupération des données depuis le payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// -- Liste des capteurs à publier, avec config Home Assistant --\nlet sensors = [\n    {\n        key: \"totalVoltage\",\n        name: \"Total voltage\",\n        unit: \"V\",\n        device_class: \"voltage\",\n        value: data.totalVoltage ? Number(data.totalVoltage).toFixed(2) : \"0.00\",\n        icon: \"mdi:car-battery\"\n    },\n    {\n        key: \"soc\",\n        name: \"State of Charge\",\n        unit: \"%\",\n        device_class: \"battery\",\n        value: data.soc || 0,\n        icon: \"mdi:battery-high\"\n    },\n    {\n        key: \"current\",\n        name: \"Current\",\n        unit: \"A\",\n        device_class: \"current\",\n        value: data.current ? Number(data.current).toFixed(1) : \"0.0\",\n        icon: \"mdi:current-dc\"\n    }\n];\n\n// -- Formatage & publication des valeurs sur topics MQTT --\nfor (let s of sensors) {\n    // Envoi de la valeur sur le topic\n    messages.push({\n        topic: `${prefix}/${s.key}`,\n        payload: String(s.value),\n        retain: true\n    });\n\n    // Génération d'un message autodiscovery Home Assistant\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\n    let config = {\n        name: `${s.name}`,\n        device_class: s.device_class,\n        state_topic: `${prefix}/${s.key}`,\n        unique_id: uniq_id_prefix + s.key,\n        unit_of_measurement: s.unit,\n        icon: s.icon,\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v3.3\"\n        }\n    };\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 580,
        "wires": [
            [
                "80a3b32d9f0f0730",
                "ecea4cb337311c7f"
            ]
        ]
    },
    {
        "id": "80a3b32d9f0f0730",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 36",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 580,
        "wires": []
    },
    {
        "id": "459611fc12f08799",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "Autre",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 150,
        "y": 1860,
        "wires": []
    },
    {
        "id": "70175f15e3a96645",
        "type": "switch",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "",
        "property": "payload.canId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "2F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "4F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "5F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "7F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "01F21400",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "1806E5F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E028F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E128F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E228F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E328F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F128F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F228F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F328F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F428F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F528F4",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 16,
        "x": 120,
        "y": 1640,
        "wires": [
            [
                "a11b6d0e18d66357"
            ],
            [
                "cc58661e52c4af01"
            ],
            [
                "49530b441302aacc"
            ],
            [
                "851759d8657506d7"
            ],
            [
                "a518317b59bd58da"
            ],
            [
                "840d9bc33fc7e3e4"
            ],
            [
                "181f7ced3cb4faf7"
            ],
            [
                "8264c8cacce70110"
            ],
            [
                "95ae122462034c80"
            ],
            [
                "890d83e4ddd29134"
            ],
            [
                "0114fcc43bfd35e2"
            ],
            [
                "0d4939b7cbb31bb3"
            ],
            [
                "5c3517a74be5a7e7"
            ],
            [
                "5832fe6540f56826"
            ],
            [
                "cc70f856bb715e58"
            ],
            [
                "459611fc12f08799"
            ]
        ]
    },
    {
        "id": "851759d8657506d7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "7F4 - Alarm",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 1500,
        "wires": []
    },
    {
        "id": "a11b6d0e18d66357",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "2F4 - main_status",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 1380,
        "wires": []
    },
    {
        "id": "cc70f856bb715e58",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F528F4 - ? compteur ??",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 440,
        "y": 2020,
        "wires": []
    },
    {
        "id": "5832fe6540f56826",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F428F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 1980,
        "wires": []
    },
    {
        "id": "cc58661e52c4af01",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "4F4 - cell_minmax",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 1420,
        "wires": []
    },
    {
        "id": "0114fcc43bfd35e2",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F128F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 1860,
        "wires": []
    },
    {
        "id": "a518317b59bd58da",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "01F21400 - monitoring",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 420,
        "y": 1540,
        "wires": []
    },
    {
        "id": "5c3517a74be5a7e7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F328F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 1940,
        "wires": []
    },
    {
        "id": "840d9bc33fc7e3e4",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "1806E5F4 - status_data",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 430,
        "y": 1580,
        "wires": []
    },
    {
        "id": "49530b441302aacc",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "5F4 - temperatures",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 1460,
        "wires": []
    },
    {
        "id": "0d4939b7cbb31bb3",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F228F4 - individual_temps",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 440,
        "y": 1900,
        "wires": []
    },
    {
        "id": "181f7ced3cb4faf7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "646f282c0dd63a6e",
        "name": "18E028F4 - cell_voltages 0 à 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 1660,
        "wires": []
    },
    {
        "id": "8264c8cacce70110",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "646f282c0dd63a6e",
        "name": "18E128F4 - cell_voltages 4 à 7",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 1700,
        "wires": []
    },
    {
        "id": "95ae122462034c80",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "646f282c0dd63a6e",
        "name": "18E228F4 - cell_voltages 8 à 11",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 1740,
        "wires": []
    },
    {
        "id": "890d83e4ddd29134",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "646f282c0dd63a6e",
        "name": "18F328F4 - cell_voltages 12 à 15",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 1780,
        "wires": []
    },
    {
        "id": "156de1e34b3811c8",
        "type": "link in",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "Debug-CAN-in",
        "links": [
            "3468acfdfe712e73"
        ],
        "x": 105,
        "y": 1440,
        "wires": [
            [
                "70175f15e3a96645"
            ]
        ]
    },
    {
        "id": "8603c29f2c2105d4",
        "type": "link in",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "Debug-CAN-in",
        "links": [
            "3468acfdfe712e73"
        ],
        "x": 90.33332824707031,
        "y": 673.1666259765625,
        "wires": [
            [
                "427020bec4bb2db0"
            ]
        ]
    },
    {
        "id": "3468acfdfe712e73",
        "type": "link out",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "Debug-CAN-out",
        "mode": "link",
        "links": [
            "156de1e34b3811c8",
            "8603c29f2c2105d4"
        ],
        "x": 945,
        "y": 420,
        "wires": []
    },
    {
        "id": "7821b4f3d5cbe3df",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "4F4 - cell_minmax",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// Définition des capteurs & paramètres à publier\nlet sensors = [\n    {\n        key: \"deltaCellVoltage\",\n        name: \"Delta Cell Votage\",\n        unit: \"V\",\n        device_class: \"voltage\",\n        value: data.deltaCellVoltage !== undefined ? data.deltaCellVoltage : 0,\n        icon: \"mdi:battery-minus-variant\"\n    },\n    {\n        key: \"maxCellVoltage\",\n        name: \"Cell max voltage\",\n        unit: \"V\",\n        device_class: \"voltage\",\n        value: data.maxCellVoltage !== undefined ? Number(data.maxCellVoltage).toFixed(2) : \"0.00\",\n        icon: \"mdi:battery-high\"\n    },\n    {\n        key: \"maxCellPosition\",\n        name: \"Cell max position\",\n        unit: \"\",\n        device_class: \"none\",\n        value: data.maxCellPosition !== undefined ? data.maxCellPosition : 0,\n        icon: \"mdi:numeric\"\n    },\n    {\n        key: \"minCellVoltage\",\n        name: \"Cell min votage\",\n        unit: \"V\",\n        device_class: \"voltage\",\n        value: data.minCellVoltage !== undefined ? data.minCellVoltage : 0,\n        icon: \"mdi:battery-low\"\n    },\n    {\n        key: \"minCellPosition\",\n        name: \"Cell min position\",\n        unit: \"\",\n        device_class: \"none\",\n        value: data.minCellPosition !== undefined ? data.minCellPosition : 0,\n        icon: \"mdi:numeric\"\n    }\n];\n\n// Loop de publication/value/discovery\nfor (let s of sensors) {\n    messages.push({\n        topic: `${prefix}/${s.key}`,\n        payload: String(s.value),\n        retain: true\n    });\n\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\n    let config = {\n        name: s.name,\n        state_topic: `${prefix}/${s.key}`,\n        unique_id: uniq_id_prefix + s.key,\n        icon: s.icon,\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v3.3\"\n        }\n    };\n\n    // Ajoute unit_of_measurement et device_class seulement si pertinent\n    if (s.unit) config.unit_of_measurement = s.unit;\n    if (s.device_class && s.device_class !== \"none\") config.device_class = s.device_class;\n\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 620,
        "wires": [
            [
                "ecea4cb337311c7f",
                "0a5f6e32247b194d"
            ]
        ]
    },
    {
        "id": "0a5f6e32247b194d",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 33",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 620,
        "wires": []
    },
    {
        "id": "75044b278b31a047",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "5F4 - temperatures",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// Définition des capteurs & paramètres à publier (avec nouveaux noms)\nlet sensors = [\n    {\n        key: \"maxTemp\",\n        name: \"Temp. Maxi\",\n        unit: \"°C\",\n        device_class: \"temperature\",\n        value: data.maxTemp !== undefined ? data.maxTemp : 0,\n        icon: \"mdi:thermometer-high\"\n    },\n    {\n        key: \"maxTempPosition\",\n        name: \"Temp. position Maxi\",\n        unit: \"\",\n        device_class: \"none\",\n        value: data.maxTempPosition !== undefined ? data.maxTempPosition : 0,\n        icon: \"mdi:numeric\"\n    },\n    {\n        key: \"minTemp\",\n        name: \"Temp. Mini\",\n        unit: \"°C\",\n        device_class: \"temperature\",\n        value: data.minTemp !== undefined ? data.minTemp : 0,\n        icon: \"mdi:thermometer-low\"\n    },\n    {\n        key: \"minTempPosition\",\n        name: \"Temp. position Mini\",\n        unit: \"\",\n        device_class: \"none\",\n        value: data.minTempPosition !== undefined ? data.minTempPosition : 0,\n        icon: \"mdi:numeric\"\n    },\n    {\n        key: \"avgTemp\",\n        name: \"Temp. Avg\",\n        unit: \"°C\",\n        device_class: \"temperature\",\n        value: data.avgTemp !== undefined ? data.avgTemp : 0,\n        icon: \"mdi:thermometer\"\n    }\n];\n\n// Publication des valeurs & autodiscovery Home Assistant\nfor (let s of sensors) {\n    messages.push({\n        topic: `${prefix}/${s.key}`,\n        payload: String(s.value),\n        retain: true\n    });\n\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\n    let config = {\n        name: s.name,\n        state_topic: `${prefix}/${s.key}`,\n        unique_id: uniq_id_prefix + s.key,\n        icon: s.icon,\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v3.3\"\n        }\n    };\n    if (s.unit) config.unit_of_measurement = s.unit;\n    if (s.device_class && s.device_class !== \"none\") config.device_class = s.device_class;\n\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 660,
        "wires": [
            [
                "ecea4cb337311c7f",
                "89d6590a094825e7"
            ]
        ]
    },
    {
        "id": "89d6590a094825e7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 14",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 660,
        "wires": []
    },
    {
        "id": "788e057cc57fcb4c",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "01F21400 - monitoring",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// ----------- Publication cycleCount uniquement ----------\nlet s = {\n    key: \"cycleCount\",\n    name: \"Cycles number\",\n    unit: \"\",\n    device_class: \"none\",\n    value: data.cycleCount !== undefined ? data.cycleCount : 0,\n    icon: \"mdi:counter\"\n};\n\n// Publication valeur brute\nmessages.push({\n    topic: `${prefix}/${s.key}`,\n    payload: String(s.value),\n    retain: true\n});\n\n// Publication auto-discovery Home Assistant\nlet discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\nlet config = {\n    name: s.name,\n    state_topic: `${prefix}/${s.key}`,\n    unique_id: uniq_id_prefix + s.key,\n    icon: s.icon,\n    expire_after: 600,\n    force_update: true,\n    device: {\n        identifiers: [deviceID],\n        name: deviceName,\n        manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n        model: \"CANbus vers MQTT\",\n        sw_version: \"v3.3\"\n    }\n};\nmessages.push({\n    topic: discoveryTopic,\n    payload: JSON.stringify(config),\n    retain: true\n});\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 740,
        "wires": [
            [
                "ecea4cb337311c7f",
                "ed8a4b44d9f1a840"
            ]
        ]
    },
    {
        "id": "ed8a4b44d9f1a840",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 35",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 740,
        "wires": []
    },
    {
        "id": "c955aacbd7372820",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "7F4 - Alarm",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// Extraction du nom de la première alarme (s'il existe)\nlet alarmName = \"\";\nif (Array.isArray(data.alarms) && data.alarms.length > 0 && data.alarms[0].name) {\n    alarmName = data.alarms[0].name;\n}\n\n// Définition du capteur\nlet s = {\n    key: \"alarmName\",\n    name: \"Alarme descr.\",\n    value: alarmName,\n    icon: \"mdi:alert-circle\"\n};\n\n// Publication de la valeur sur le topic MQTT\nmessages.push({\n    topic: `${prefix}/${s.key}`,\n    payload: s.value,\n    retain: true\n});\n\n// Configuration autodiscovery Home Assistant - sensor texte (pas d'unité)\nlet discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\nlet config = {\n    name: s.name,\n    state_topic: `${prefix}/${s.key}`,\n    unique_id: uniq_id_prefix + s.key,\n    icon: s.icon,\n    expire_after: 600,\n    device: {\n        identifiers: [deviceID],\n        name: deviceName,\n        manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n        model: \"CANbus vers MQTT\",\n        sw_version: \"v3.3\"\n    }\n};\nmessages.push({\n    topic: discoveryTopic,\n    payload: JSON.stringify(config),\n    retain: true\n});\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 700,
        "wires": [
            [
                "ecea4cb337311c7f",
                "33664bc1723b2cde"
            ]
        ]
    },
    {
        "id": "33664bc1723b2cde",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 38",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 700,
        "wires": []
    },
    {
        "id": "59a32da84f1d558f",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "18E028F4 - cell_voltages 0 à 3",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1/cellVoltage_\";  // <-- maintenant underscore\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_cell_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\nif (Array.isArray(data.voltages)) {\n    for (let cell of data.voltages) {\n        let cellNumber = cell.cellNumber || 0;\n        let voltage = cell.voltage !== undefined ? Number(cell.voltage).toFixed(3) : \"0.000\";\n        let key = `${cellNumber}`;\n\n        // 1) Publication de la tension de cette cellule sur son topic dédié\n        messages.push({\n            topic: `${prefix}${key}`,\n            payload: voltage,\n            retain: true\n        });\n\n        // 2) Autodiscovery HA pour cette cellule\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/cell_voltage_${key}/config`;\n        let config = {\n            name: `Cell ${cellNumber}`,\n            state_topic: `${prefix}${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"voltage\",\n            unit_of_measurement: \"V\",\n            icon: \"mdi:battery\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v3.3\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 860,
        "wires": [
            [
                "1b8d8f8af7b7474f",
                "6012cd81c0bcf535"
            ]
        ]
    },
    {
        "id": "6012cd81c0bcf535",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "debug 39",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 860,
        "wires": []
    },
    {
        "id": "7052b31a5e638f20",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "18E128F4 - cell_voltages 4 à 7",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1/cellVoltage_\"; // underscore\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_cell_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\nif (Array.isArray(data.voltages)) {\n    for (let cell of data.voltages) {\n        let cellNumber = cell.cellNumber || 0;\n        let voltage = cell.voltage !== undefined ? Number(cell.voltage).toFixed(3) : \"0.000\";\n        let key = `${cellNumber}`;\n\n        // 1) Publication de la tension de cette cellule sur son topic dédié\n        messages.push({\n            topic: `${prefix}${key}`,\n            payload: voltage,\n            retain: true\n        });\n\n        // 2) Autodiscovery HA pour cette cellule\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/cell_voltage_${key}/config`;\n        let config = {\n            name: `Cell ${cellNumber}`,\n            state_topic: `${prefix}${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"voltage\",\n            unit_of_measurement: \"V\",\n            icon: \"mdi:battery\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v3.3\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 900,
        "wires": [
            [
                "1b8d8f8af7b7474f",
                "13609daae25e3257"
            ]
        ]
    },
    {
        "id": "13609daae25e3257",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "debug 40",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 900,
        "wires": []
    },
    {
        "id": "52d83545146677d4",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "18E228F4 - cell_voltages 8 à 11",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1/cellVoltage_\"; // underscore\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_cell_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\nif (Array.isArray(data.voltages)) {\n    for (let cell of data.voltages) {\n        let cellNumber = cell.cellNumber || 0;\n        let voltage = cell.voltage !== undefined ? Number(cell.voltage).toFixed(3) : \"0.000\";\n        let key = `${cellNumber}`;\n\n        // 1) Publication de la tension de cette cellule sur son topic dédié\n        messages.push({\n            topic: `${prefix}${key}`,\n            payload: voltage,\n            retain: true\n        });\n\n        // 2) Autodiscovery HA pour cette cellule\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/cell_voltage_${key}/config`;\n        let config = {\n            name: `Cell ${cellNumber}`,\n            state_topic: `${prefix}${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"voltage\",\n            unit_of_measurement: \"V\",\n            icon: \"mdi:battery\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v3.3\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 940,
        "wires": [
            [
                "1b8d8f8af7b7474f",
                "5902f421447b046d"
            ]
        ]
    },
    {
        "id": "5902f421447b046d",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "debug 41",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 940,
        "wires": []
    },
    {
        "id": "e78e87fb719b450d",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "18F328F4 - cell_voltages 12 à 15",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1/cellVoltage_\"; // underscore\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_cell_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\nif (Array.isArray(data.voltages)) {\n    for (let cell of data.voltages) {\n        let cellNumber = cell.cellNumber || 0;\n        let voltage = cell.voltage !== undefined ? Number(cell.voltage).toFixed(3) : \"0.000\";\n        let key = `${cellNumber}`;\n\n        // 1) Publication de la tension sur le topic dédié\n        messages.push({\n            topic: `${prefix}${key}`,\n            payload: voltage,\n            retain: true\n        });\n\n        // 2) Autodiscovery Home Assistant pour cette cellule\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/cell_voltage_${key}/config`;\n        let config = {\n            name: `Cell ${cellNumber}`,\n            state_topic: `${prefix}${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"voltage\",\n            unit_of_measurement: \"V\",\n            icon: \"mdi:battery\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v3.3\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 980,
        "wires": [
            [
                "1b8d8f8af7b7474f",
                "c50f23a0e0297de8"
            ]
        ]
    },
    {
        "id": "c50f23a0e0297de8",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "debug 42",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 980,
        "wires": []
    },
    {
        "id": "8c4ae23f7fadd63d",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F228F4 - individual_temps",
        "func": "let data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// 1) Températures individuelles\nif (Array.isArray(data.temperatures)) {\n    for (let i = 0; i < data.temperatures.length; i++) {\n        let temp = data.temperatures[i];\n        let key = `temperature_${i+1}`;\n\n        messages.push({\n            topic: `${prefix}/${key}`,\n            payload: temp !== undefined ? String(temp) : \"\",\n            retain: true\n        });\n\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${key}/config`;\n        let config = {\n            name: `Temp. Sonde ${i+1}`,\n            state_topic: `${prefix}/${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"temperature\",\n            unit_of_measurement: \"°C\",\n            icon: \"mdi:thermometer\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v3.3\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\n// 2) Température MOSFET\nif (data.mosTemp !== undefined) {\n    messages.push({\n        topic: `${prefix}/mosTemp`,\n        payload: String(data.mosTemp),\n        retain: true\n    });\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/mosTemp/config`;\n    let config = {\n        name: `Temp. MOSFET`,\n        state_topic: `${prefix}/mosTemp`,\n        unique_id: uniq_id_prefix + \"mosTemp\",\n        device_class: \"temperature\",\n        unit_of_measurement: \"°C\",\n        icon: \"mdi:thermometer-lines\",\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v3.3\"\n        }\n    };\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\n// 3) Nombre de sondes\nif (data.sensorCount !== undefined) {\n    messages.push({\n        topic: `${prefix}/TempSensorCount`,\n        payload: String(data.sensorCount),\n        retain: true\n    });\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/TempSensorCount/config`;\n    let config = {\n        name: `Nb. of probes temp.`,\n        state_topic: `${prefix}/TempSensorCount`,\n        unique_id: uniq_id_prefix + \"TempSensorCount\",\n        icon: \"mdi:counter\",\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v3.3\"\n        }\n    };\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 1120,
        "wires": [
            [
                "5db3845569e2eacb",
                "cf27fc9e687cec75"
            ]
        ]
    },
    {
        "id": "cf27fc9e687cec75",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 43",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 1120,
        "wires": []
    },
    {
        "id": "ecea4cb337311c7f",
        "type": "link out",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "CAN-to-MQTT-out",
        "mode": "link",
        "links": [
            "7cdddbdff16d1585"
        ],
        "x": 835,
        "y": 680,
        "wires": []
    },
    {
        "id": "7cdddbdff16d1585",
        "type": "link in",
        "z": "2e99fd421b434bcb",
        "g": "b188deca5d12b002",
        "name": "CAN-to-MQTT-in",
        "links": [
            "ecea4cb337311c7f",
            "1b8d8f8af7b7474f",
            "5db3845569e2eacb"
        ],
        "x": 745,
        "y": 1240,
        "wires": [
            [
                "f491a2b292a65e24"
            ]
        ]
    },
    {
        "id": "f491a2b292a65e24",
        "type": "mqtt out",
        "z": "2e99fd421b434bcb",
        "g": "b188deca5d12b002",
        "name": "Onduleur",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 840,
        "y": 1240,
        "wires": []
    },
    {
        "id": "1b8d8f8af7b7474f",
        "type": "link out",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "CAN-to-MQTT-out",
        "mode": "link",
        "links": [
            "7cdddbdff16d1585"
        ],
        "x": 855,
        "y": 920,
        "wires": []
    },
    {
        "id": "5db3845569e2eacb",
        "type": "link out",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "CAN-to-MQTT-out",
        "mode": "link",
        "links": [
            "7cdddbdff16d1585"
        ],
        "x": 815,
        "y": 1140,
        "wires": []
    },
    {
        "id": "21eb77fc0deb7df8",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "3",
        "nbRateUnits": "15",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 580,
        "wires": [
            [
                "e7576279e8153b1b"
            ]
        ]
    },
    {
        "id": "91aacf4dfc2f6b45",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 620,
        "wires": [
            [
                "7821b4f3d5cbe3df"
            ]
        ]
    },
    {
        "id": "8144d8148f4c0840",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 660,
        "wires": [
            [
                "75044b278b31a047"
            ]
        ]
    },
    {
        "id": "1daa9e6390671ea8",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 700,
        "wires": [
            [
                "c955aacbd7372820"
            ]
        ]
    },
    {
        "id": "72b36b4609b42dba",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 740,
        "wires": [
            [
                "788e057cc57fcb4c"
            ]
        ]
    },
    {
        "id": "7d97f7131d3497a0",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 860,
        "wires": [
            [
                "59a32da84f1d558f"
            ]
        ]
    },
    {
        "id": "32e8d6abd9ac44d0",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 900,
        "wires": [
            [
                "7052b31a5e638f20"
            ]
        ]
    },
    {
        "id": "740e7dc1d40c5efa",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 940,
        "wires": [
            [
                "52d83545146677d4"
            ]
        ]
    },
    {
        "id": "4be4303ae0f078dc",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 980,
        "wires": [
            [
                "e78e87fb719b450d"
            ]
        ]
    },
    {
        "id": "0005b67220843057",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 1120,
        "wires": [
            [
                "8c4ae23f7fadd63d"
            ]
        ]
    },
    {
        "id": "5cfaee00ed1d945e",
        "type": "switch",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "false"
            },
            {
                "t": "true"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 330,
        "y": 60,
        "wires": [
            [],
            [
                "81797f8435ea4090",
                "918a82299c32dcf9"
            ]
        ]
    },
    {
        "id": "93acca2bdf879a01",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 60,
        "wires": [
            [
                "5cfaee00ed1d945e"
            ]
        ]
    },
    {
        "id": "81797f8435ea4090",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "command": "ip link set can0 down",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 220,
        "y": 120,
        "wires": [
            [
                "b5fefa24fa332bb0",
                "b3cc6af46b5e8003"
            ],
            [],
            []
        ]
    },
    {
        "id": "33e185e362f95f82",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "command": "ip link set can0 up type can bitrate 500000",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 280,
        "y": 180,
        "wires": [
            [
                "a1212ebb1907b570",
                "89480d3fdae61266"
            ],
            [],
            []
        ]
    },
    {
        "id": "d09a3cc293255be2",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "command": "ip link set can0 up",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 210,
        "y": 240,
        "wires": [
            [
                "4c7382e365ab7a48",
                "606759ae352bbf73"
            ],
            [],
            []
        ]
    },
    {
        "id": "4c7382e365ab7a48",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 540,
        "y": 240,
        "wires": [
            [
                "c3de74fe6e67e34d"
            ]
        ]
    },
    {
        "id": "0ef8fc221e14acf6",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "command": "ip link set can0 down",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1040,
        "y": 1700,
        "wires": [
            [
                "ab0eed874c8d277a"
            ],
            [],
            [
                "505be46f8eda2768"
            ]
        ]
    },
    {
        "id": "bfc557c471275022",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 850,
        "y": 1700,
        "wires": [
            [
                "0ef8fc221e14acf6"
            ]
        ]
    },
    {
        "id": "ab0eed874c8d277a",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 29",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1680,
        "wires": []
    },
    {
        "id": "505be46f8eda2768",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 31",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1720,
        "wires": []
    },
    {
        "id": "f73071ac18154111",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "command": "ip link set can0 up",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1030,
        "y": 1620,
        "wires": [
            [
                "876fccdff470c9e9"
            ],
            [],
            [
                "7dc27bfd806f5368"
            ]
        ]
    },
    {
        "id": "f5dfca4e639fa942",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 850,
        "y": 1620,
        "wires": [
            [
                "f73071ac18154111"
            ]
        ]
    },
    {
        "id": "876fccdff470c9e9",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 32",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1600,
        "wires": []
    },
    {
        "id": "7dc27bfd806f5368",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 34",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1640,
        "wires": []
    },
    {
        "id": "c3b71c2f1a714c85",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "command": "ip link set can0 up type can bitrate 500000",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1120,
        "y": 1500,
        "wires": [
            [
                "4b1f866ae32190f9"
            ],
            [],
            [
                "ac59461acfb2cc71"
            ]
        ]
    },
    {
        "id": "64ae959294b9f406",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 850,
        "y": 1500,
        "wires": [
            [
                "c3b71c2f1a714c85"
            ]
        ]
    },
    {
        "id": "4b1f866ae32190f9",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 1480,
        "wires": []
    },
    {
        "id": "ac59461acfb2cc71",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 28",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 1520,
        "wires": []
    },
    {
        "id": "0d119ba5972c169a",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "ccc1258cc5051fb2",
        "command": "ip link show can0",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1050,
        "y": 1880,
        "wires": [
            [
                "e568cd8b91c96fff"
            ],
            [],
            [
                "19e2a3758a49f532"
            ]
        ]
    },
    {
        "id": "91b2a628817de544",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "ccc1258cc5051fb2",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 850,
        "y": 1880,
        "wires": [
            [
                "0d119ba5972c169a"
            ]
        ]
    },
    {
        "id": "e568cd8b91c96fff",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "ccc1258cc5051fb2",
        "name": "debug 19",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 1860,
        "wires": []
    },
    {
        "id": "19e2a3758a49f532",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "ccc1258cc5051fb2",
        "name": "debug 27",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 1900,
        "wires": []
    },
    {
        "id": "b3cc6af46b5e8003",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "CAN Down",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 750,
        "y": 120,
        "wires": []
    },
    {
        "id": "69e938ba030b7546",
        "type": "change",
        "z": "2e99fd421b434bcb",
        "g": "fcb249897b0ead9e",
        "name": "CAN_bus_usage ? False",
        "rules": [
            {
                "t": "set",
                "p": "CAN_bus_usage",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1250,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "795828b453f64b9b",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "fcb249897b0ead9e",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1030,
        "y": 100,
        "wires": [
            [
                "748d73da83bca2cf"
            ]
        ]
    },
    {
        "id": "748d73da83bca2cf",
        "type": "change",
        "z": "2e99fd421b434bcb",
        "g": "fcb249897b0ead9e",
        "name": "CAN_bus_usage ? True",
        "rules": [
            {
                "t": "set",
                "p": "CAN_bus_usage",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1250,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "b30c7fb6356f631e",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "fcb249897b0ead9e",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1030,
        "y": 140,
        "wires": [
            [
                "69e938ba030b7546"
            ]
        ]
    },
    {
        "id": "b5fefa24fa332bb0",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 540,
        "y": 120,
        "wires": [
            [
                "33e185e362f95f82"
            ]
        ]
    },
    {
        "id": "a1212ebb1907b570",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 540,
        "y": 180,
        "wires": [
            [
                "d09a3cc293255be2"
            ]
        ]
    },
    {
        "id": "89480d3fdae61266",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "bds",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 180,
        "wires": []
    },
    {
        "id": "606759ae352bbf73",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "CAN Up",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 240,
        "wires": []
    },
    {
        "id": "918a82299c32dcf9",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "Using CANbus",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 60,
        "wires": []
    },
    {
        "id": "inject_startup_v2",
        "type": "inject",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "name": "Au démarrage",
        "props": [],
        "repeat": "",
        "crontab": "00 15 * * *",
        "once": true,
        "onceDelay": "15",
        "topic": "",
        "x": 240,
        "y": 160,
        "wires": [
            [
                "c0a1550183f24e9b"
            ]
        ]
    },
    {
        "id": "exec_test_os",
        "type": "exec",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "command": "uname -s 2>nul || echo Windows",
        "addpay": false,
        "append": "",
        "useSpawn": "false",
        "timer": "2",
        "winHide": true,
        "oldrc": false,
        "name": "Test OS basique",
        "x": 620,
        "y": 180,
        "wires": [
            [
                "switch_os"
            ],
            [],
            []
        ]
    },
    {
        "id": "switch_os",
        "type": "switch",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "name": "Windows ou Linux?",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "Windows",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 270,
        "y": 280,
        "wires": [
            [
                "set_windows"
            ],
            [
                "exec_detect_linux_detail"
            ]
        ]
    },
    {
        "id": "set_windows",
        "type": "change",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "name": "Windows détecté",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "Windows",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 510,
        "y": 260,
        "wires": [
            [
                "parse_env_v2"
            ]
        ]
    },
    {
        "id": "exec_detect_linux_detail",
        "type": "exec",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "command": "([ -n \"$SUPERVISOR_TOKEN\" ] || [ -n \"$HASSIO_TOKEN\" ] || [ -f /etc/hassio.json ] || [ -d /usr/share/hassio ]) && echo 'HAOS' || ([ -f /.dockerenv ] && echo 'Docker') || echo 'Linux'",
        "addpay": false,
        "append": "",
        "useSpawn": "false",
        "timer": "3",
        "winHide": false,
        "oldrc": false,
        "name": "Détail Linux",
        "x": 490,
        "y": 300,
        "wires": [
            [
                "parse_env_v2"
            ],
            [],
            []
        ]
    },
    {
        "id": "parse_env_v2",
        "type": "function",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "name": "Analyse environnement",
        "func": "const inputEnv = msg.payload.toString().trim();\n\nlet configPath;\nlet statusColor;\nlet bip;\n\nswitch(inputEnv) {\n    case 'HAOS':\n        configPath = '/data/options.json';\n        msg.environment = 'Home Assistant OS';\n        bip = 1;\n        statusColor = 'green';\n        break;\n    case 'Docker':\n        configPath = '/data/options.json';\n        msg.environment = 'Docker (autre)';\n        bip = 2;\n        statusColor = 'blue';\n        break;\n    case 'Linux':\n        configPath = '/data/options.json';\n        msg.environment = 'Linux barebone';\n        bip = 3;\n        statusColor = 'yellow';\n        break;\n    case 'Windows':\n        configPath = 'C:\\\\data\\\\options.json';\n        msg.environment = 'Windows';\n        bip = 4;\n        statusColor = 'purple';\n        break;\n    default:\n        configPath = './data/options.json';\n        msg.environment = 'Inconnu';\n        bip = 5;\n        statusColor = 'red';\n}\n\nmsg.filename = configPath;\nmsg.payload = {\"bip\": String(bip)};\nmsg.headers = {\n    \"Content-Type\": \"application/json\"\n};\nnode.status({fill:statusColor, shape:\"dot\", text: msg.environment});\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 300,
        "wires": [
            [
                "file_read_v2",
                "72f87905871f38b0",
                "7d18ea54123e1414"
            ]
        ]
    },
    {
        "id": "file_read_v2",
        "type": "file in",
        "z": "44f1a774d989bad2",
        "d": true,
        "g": "3eae94408690a564",
        "name": "Lit options.json",
        "filename": "filename",
        "filenameType": "msg",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 700,
        "y": 380,
        "wires": [
            [
                "parse_json_v2"
            ]
        ]
    },
    {
        "id": "parse_json_v2",
        "type": "json",
        "z": "44f1a774d989bad2",
        "d": true,
        "g": "3eae94408690a564",
        "name": "Parse JSON",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 870,
        "y": 380,
        "wires": [
            [
                "debug_config_v2"
            ]
        ]
    },
    {
        "id": "debug_config_v2",
        "type": "debug",
        "z": "44f1a774d989bad2",
        "d": true,
        "g": "3eae94408690a564",
        "name": "Config chargée",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 1080,
        "y": 380,
        "wires": []
    },
    {
        "id": "72f87905871f38b0",
        "type": "debug",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "name": "OS type",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 260,
        "wires": []
    },
    {
        "id": "c0a1550183f24e9b",
        "type": "switch",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "name": "bip permis ?",
        "property": "Send_bip",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 430,
        "y": 160,
        "wires": [
            [
                "exec_test_os"
            ],
            []
        ]
    },
    {
        "id": "7d18ea54123e1414",
        "type": "http request",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "name": "POST",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://www.smartphoton.ch/jkbms-endpoint.php",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 970,
        "y": 300,
        "wires": [
            [
                "4c19e94f627591cd"
            ]
        ]
    },
    {
        "id": "4c19e94f627591cd",
        "type": "debug",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "name": "debug 21",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1120,
        "y": 300,
        "wires": []
    },
    {
        "id": "4b5571fbcfbfbc8c",
        "type": "inject",
        "z": "44f1a774d989bad2",
        "g": "3eae94408690a564",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 230,
        "y": 200,
        "wires": [
            [
                "exec_test_os"
            ]
        ]
    },
    {
        "id": "90589e2e759450b0",
        "type": "link in",
        "z": "e046a6ce6457b012",
        "g": "f382b31e2c58e8c3",
        "name": "Dashboard-Live-Data-In",
        "links": [
            "8756d698a33880b8"
        ],
        "x": 345,
        "y": 380,
        "wires": [
            [
                "72858cb8135ecca1"
            ]
        ]
    },
    {
        "id": "72858cb8135ecca1",
        "type": "function",
        "z": "e046a6ce6457b012",
        "g": "f382b31e2c58e8c3",
        "name": "Dynamique dashboard",
        "func": "// Récupérer l'adresse du BMS depuis la variable globale\nconst bmsAddress = global.get('slaveAddress-Trame3') || 'BMS-Unknown';\n\n// Extraire les données de tension des cellules\nconst cellVoltages = [];\nfor (let i = 1; i <= 16; i++) {\n    const key = `Cell_${i}_volt_V`;\n    if (msg.payload[key] !== undefined) {\n        cellVoltages.push({\n            cell: i,\n            voltage: parseFloat(msg.payload[key]).toFixed(3)\n        });\n    }\n}\n\n// Calculer min, max et moyenne des tensions\nconst voltages = cellVoltages.map(c => parseFloat(c.voltage));\nconst minVoltage = Math.min(...voltages);\nconst maxVoltage = Math.max(...voltages);\nconst avgVoltage = (voltages.reduce((a, b) => a + b, 0) / voltages.length).toFixed(3);\nconst voltageBalance = (maxVoltage - minVoltage).toFixed(3);\n\n// Extraire les données de température\nconst temperatures = [\n    { name: 'MOS', value: msg.payload.Mos_temp_T },\n    { name: 'Sonde 1', value: msg.payload.Sonde_1_temp_T },\n    { name: 'Sonde 2', value: msg.payload.Sonde_2_temp_T },\n    { name: 'Sonde 3', value: msg.payload.Sonde_3_temp_T },\n    { name: 'Sonde 4', value: msg.payload.Sonde_4_temp_T }\n].filter(t => t.value !== undefined);\n\nconst maxTemp = Math.max(...temperatures.map(t => t.value));\nconst minTemp = Math.min(...temperatures.map(t => t.value));\n\n// Construire l'objet formaté pour le dashboard\nconst formattedData = {\n    bmsAddress: bmsAddress,\n    timestamp: new Date().toISOString(),\n    \n    // Tension globale\n    tensionTotale: {\n        value: msg.payload.Tension_Totale_volt_V,\n        unit: 'V'\n    },\n    \n    // Courant\n    courantTotal: {\n        value: msg.payload.Courant_total_A,\n        unit: 'A'\n    },\n    \n    // Puissance\n    puissance: {\n        value: msg.payload.Puissance_Totale_W,\n        unit: 'W'\n    },\n    \n    // État de charge\n    soc: {\n        value: msg.payload.SOC_pourcentage_P,\n        unit: '%'\n    },\n    \n    // État de santé\n    soh: {\n        value: msg.payload.SOH_pourcentage_P,\n        unit: '%'\n    },\n    \n    // Capacité\n    capacite: {\n        restante: msg.payload.Capacite_restante_Ah,\n        totale: msg.payload.Capacite_batterie_Ah,\n        unit: 'Ah'\n    },\n    \n    // Cellules\n    cellules: {\n        count: cellVoltages.length,\n        voltages: cellVoltages,\n        minVoltage: minVoltage,\n        maxVoltage: maxVoltage,\n        avgVoltage: avgVoltage,\n        balance: voltageBalance // Différence V entre la plus haute et plus basse\n    },\n    \n    // Températures\n    temperatures: {\n        sensors: temperatures,\n        max: maxTemp,\n        min: minTemp\n    },\n    \n    // États des switchs\n    switches: {\n        charge: msg.payload.Switch_Charge_B === 1,\n        decharge: msg.payload.Switch_Decharge_B === 1,\n        balance: msg.payload.Switch_Balance_B === 1,\n        heating: msg.payload.Heating_B === 1\n    },\n    \n    // Équilibrage\n    balance: {\n        courant: msg.payload.Balance_courant_A,\n        action: msg.payload.Balance_Action_B === 1,\n        unit: 'A'\n    },\n    \n    // Cycles et runtime\n    maintenance: {\n        nombreCycles: msg.payload.Nombre_Cycle_N,\n        capaciteCycles: msg.payload.Cycle_Capacite_Ah,\n        runtimeTotal: msg.payload.Total_runtime_S,\n        runtimeHours: (msg.payload.Total_runtime_S / 3600).toFixed(2)\n    }\n};\n\n// Passer les données formatées au message\nmsg.payload = formattedData;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 380,
        "wires": [
            [
                "6c3251dbb536e412"
            ]
        ]
    },
    {
        "id": "6c3251dbb536e412",
        "type": "switch",
        "z": "e046a6ce6457b012",
        "g": "f382b31e2c58e8c3",
        "name": "Trier par BMS Address",
        "property": "payload.bmsAddress",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "1",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "2",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 760,
        "y": 380,
        "wires": [
            [
                "4669a15e5fbce50a"
            ],
            []
        ]
    },
    {
        "id": "41569635140450b8",
        "type": "link in",
        "z": "e046a6ce6457b012",
        "g": "76fabc0223d5e539",
        "name": "Dashboard-Static-Data-In",
        "links": [
            "32f3c0d652235f1c"
        ],
        "x": 195,
        "y": 100,
        "wires": [
            [
                "3f54927a8562ef8c"
            ]
        ]
    },
    {
        "id": "3f54927a8562ef8c",
        "type": "function",
        "z": "e046a6ce6457b012",
        "g": "76fabc0223d5e539",
        "name": "Statique dashboard",
        "func": "// Récupérer l'adresse du BMS\nconst bmsAddress = global.get('slaveAddress-Trame1') || '1';\nconst d = msg.payload;\n\n// Calcul de l'uptime\nconst days = Math.floor(d.Uptime_S / (24 * 3600));\nconst hours = Math.floor((d.Uptime_S % (24 * 3600)) / 3600);\n\n// Construire l'objet formaté complet\nmsg.payload = {\n    bmsAddress: bmsAddress,\n    timestamp: new Date().toISOString(),\n    modele: d.BMS_A,\n    serie: d.SerialNb_N,\n    marque: d.Brand_A,\n    firmware: d.FW_A,\n    software: d.SW_N,\n    powerCount: d.Power_count_N,\n    uptime: days + \"j \" + hours + \"h\",\n    dateFab: d.Manufacturing_date_N,\n    buzzer: {\n        trigger: d.LCD_buzzer_trigger_value_N,\n        release: d.LCD_buzzer_release_value_N\n    },\n    params: {\n        chargeV: d.Request_Charge_voltage_Time_H,\n        floatV: d.Request_Float_voltage_Time_H,\n        canProt: d.CAN_protocol_number_N\n    }\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 100,
        "wires": [
            [
                "88076e010f936d8b"
            ]
        ]
    },
    {
        "id": "88076e010f936d8b",
        "type": "switch",
        "z": "e046a6ce6457b012",
        "g": "76fabc0223d5e539",
        "name": "Trier par BMS Address",
        "property": "payload.bmsAddress",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "1",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "2",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 650,
        "y": 100,
        "wires": [
            [
                "09f010af7c5e1992"
            ],
            []
        ]
    },
    {
        "id": "4669a15e5fbce50a",
        "type": "ui-template",
        "z": "e046a6ce6457b012",
        "g": "f382b31e2c58e8c3",
        "group": "group_bms1",
        "page": "",
        "ui": "",
        "name": "BMS 1 - COMPLET BLEU",
        "order": 1,
        "width": "0",
        "height": "0",
        "format": "<div v-if=\"msg && msg.payload\" style=\"font-family:'Segoe UI',sans-serif;background:linear-gradient(135deg,#1e3c72 0%,#2a5298 100%);min-height:100vh;padding:20px;margin:-20px\">\n    <div style=\"max-width:1400px;margin:0 auto\">\n        \n        <div style=\"color:#fff;margin-bottom:20px;display:flex;justify-content:center;align-items:baseline;gap:20px\">\n            <h1 style=\"font-size:2em;margin:0\">⚡ BMS #1</h1>\n            <span style=\"opacity:.9;font-size:1.1em;font-weight:300\">\n                Dernière lecture: {{ new Date(msg.payload.timestamp).toLocaleDateString('fr-FR') }} {{ new Date(msg.payload.timestamp).toLocaleTimeString('fr-FR') }}\n            </span>\n        </div>\n\n        <div style=\"display:grid;grid-template-columns:repeat(4,1fr);gap:15px;margin-bottom:30px\">\n            <div v-for=\"(val, label) in {\n                'Tension':   {v:msg.payload.tensionTotale.value, min:40, max:60, u:'V'},\n                'Courant':   {v:Math.abs(msg.payload.courantTotal.value), min:0, max:200, u:'A'},\n                'Puissance': {v:Math.abs(msg.payload.puissance.value), min:0, max:6000, u:'W'}\n            }\" style=\"background:rgba(255,255,255,0.15); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.2); border-radius:15px; padding:15px; text-align:center; box-shadow:0 8px 32px rgba(0,0,0,0.2)\">\n                <div style=\"color:#ddd;font-size:.8em;font-weight:700;text-transform:uppercase\">{{label}}</div>\n                <div style=\"position:relative;height:80px;margin-top:10px\">\n                    <svg viewBox=\"0 0 100 55\" style=\"width:100%;height:100%\">\n                        <path d=\"M 10 50 A 40 40 0 0 1 90 50\" fill=\"none\" stroke=\"rgba(255,255,255,0.2)\" stroke-width=\"8\" stroke-linecap=\"round\"/>\n                        <path d=\"M 10 50 A 40 40 0 0 1 90 50\" fill=\"none\" stroke=\"#60a5fa\" \n                              stroke-width=\"8\" stroke-linecap=\"round\" \n                              :style=\"{ strokeDasharray: (Math.max(0, Math.min((val.v - val.min) / (val.max - val.min), 1)) * 126) + ', 126' }\" \n                              style=\"transition: stroke-dasharray 0.5s ease\"/>\n                    </svg>\n                    <div style=\"position:absolute;bottom:0;width:100%;font-size:1.4em;font-weight:800;color:#fff\">\n                        {{val.v.toFixed(label==='Puissance'?0:2)}}<span style=\"font-size:0.6em;margin-left:2px\">{{val.u}}</span>\n                    </div>\n                </div>\n            </div>\n\n            <div style=\"background:rgba(255,255,255,0.15); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.2); border-radius:15px; padding:15px; text-align:center; box-shadow:0 8px 32px rgba(0,0,0,0.2); display:flex; flex-direction:column; justify-content:center\">\n                <div style=\"color:#ddd;font-size:.8em;font-weight:700;text-transform:uppercase;margin-bottom:10px\">SOC</div>\n                <div style=\"display:flex;align-items:center;justify-content:center;gap:12px\">\n                    <div style=\"position:relative;width:45px;height:22px;border:2px solid #fff;border-radius:5px;padding:2px\">\n                        <div :style=\"{width:msg.payload.soc.value+'%',background:msg.payload.soc.value<20?'#ef4444':(msg.payload.soc.value<50?'#f59e0b':'#10b981')}\" style=\"height:100%;border-radius:1px;transition:width .5s\"></div>\n                        <div style=\"position:absolute;right:-6px;top:4px;width:4px;height:10px;background:#fff;border-radius:0 2px 2px 0\"></div>\n                    </div>\n                    <div style=\"font-size:2em;font-weight:800;color:#fff\">{{msg.payload.soc.value}}%</div>\n                </div>\n            </div>\n        </div>\n\n        <div style=\"margin-bottom:30px\">\n            <h2 style=\"color:#fff;font-size:1.4em;margin-bottom:15px;border-left:4px solid #fff;padding-left:15px\">Détail des Cellules</h2>\n            <div style=\"display:grid;grid-template-columns:repeat(8,1fr);gap:10px\">\n                <div v-for=\"cell in msg.payload.cellules.voltages\" :key=\"cell.cell\" \n                     :style=\"{background:(function(){\n                        const cellVoltage = parseFloat(cell.voltage);\n                        const voltages = msg.payload.cellules.voltages.map(c => parseFloat(c.voltage));\n                        const minVoltage = Math.min(...voltages);\n                        const maxVoltage = Math.max(...voltages);\n                        \n                        if(cellVoltage === maxVoltage) return 'rgba(96, 165, 250, 0.4)'; // Bleu\n                        if(cellVoltage === minVoltage) return 'rgba(239, 68, 68, 0.4)';  // Rouge\n                        if(Math.abs(cellVoltage - parseFloat(msg.payload.cellules.avgVoltage)) > 0.02) return 'rgba(255,193,7,0.3)'; // Jaune\n                        return 'rgba(255,255,255,0.1)'; // Normal\n                     })()}\" \n                     style=\"backdrop-filter:blur(5px); border:1px solid rgba(255,255,255,0.1); border-radius:8px; padding:12px 2px; text-align:center; color:#fff\">\n                    <div style=\"font-size:.7em;color:#ddd\">C{{cell.cell}}</div>\n                    <div style=\"font-size:1.3em;font-weight:800\">{{parseFloat(cell.voltage).toFixed(3)}}</div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Section réorganisée en 3 colonnes -->\n        <div style=\"display:grid;grid-template-columns:repeat(3,1fr);gap:20px;margin-bottom:30px\">\n            <!-- Températures - réduite à 1 colonne -->\n            <div style=\"background:rgba(255,255,255,0.15); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.2); border-radius:12px; padding:20px; color:#fff\">\n                <h3 style=\"margin:0 0 15px 0;color:#fff;border-bottom:1px solid rgba(255,255,255,0.2);padding-bottom:10px\">🌡️ Températures</h3>\n                <div v-for=\"temp in msg.payload.temperatures.sensors\" style=\"display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px dashed rgba(255,255,255,0.1)\">\n                    <span>{{temp.name}}</span><b style=\"color:#60a5fa\">{{temp.value.toFixed(1)}}°C</b>\n                </div>\n            </div>\n\n            <!-- États Commandes - réduit à 1 colonne -->\n            <div style=\"background:rgba(255,255,255,0.15); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.2); border-radius:12px; padding:20px; color:#fff\">\n                <h3 style=\"margin:0 0 15px 0;color:#fff;border-bottom:1px solid rgba(255,255,255,0.2);padding-bottom:10px\">🔌 États Commandes</h3>\n                <div v-for=\"(val, key) in msg.payload.switches\" style=\"display:flex;align-items:center;padding:8px 0\">\n                    <div :style=\"{background:val?'#10b981':'#ef4444'}\" style=\"width:12px;height:12px;border-radius:50%;margin-right:10px;box-shadow:0 0 8px rgba(0,0,0,0.3)\"></div>\n                    <span style=\"text-transform:capitalize\">{{key}}: <b>{{val?'ON':'OFF'}}</b></span>\n                </div>\n            </div>\n\n            <!-- Widget Ko-fi - 1 colonne -->\n            <div style=\"background:rgba(255,255,255,0.15); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.2); border-radius:12px; padding:20px; display:flex;flex-direction:column;justify-content:center;align-items:center;gap:12px\">\n                <div style=\"color:#fff;font-size:1.2em;font-weight:600\">Support me on Ko-fi</div>\n                <a href='https://ko-fi.com/Y8Y3YHYZP' target='_blank' style=\"display:flex;justify-content:center\"><img height='60' style='border:0px;height:60px;' src='https://storage.ko-fi.com/cdn/kofi6.png?v=6' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a>\n            </div>\n        </div>\n\n        <div style=\"background:rgba(255,255,255,0.1); backdrop-filter:blur(15px); border:1px solid rgba(255,255,255,0.1); border-radius:12px; padding:20px; display:grid; grid-template-columns:repeat(4,1fr); gap:20px; text-align:center; color:#fff\">\n            <div v-for=\"(v, k) in {\n                'CYCLES':msg.payload.maintenance.nombreCycles, \n                'SOH':msg.payload.soh.value+'%', \n                'CAPACITÉ':msg.payload.capacite.restante+'Ah', \n                'RUNTIME':(function(){\n                    const hours = msg.payload.maintenance.runtimeHours;\n                    const days = Math.floor(hours / 24);\n                    const hrs = Math.floor(hours % 24);\n                    const mins = Math.round((hours % 1) * 60);\n                    return days + 'D-' + String(hrs).padStart(2,'0') + 'H-' + String(mins).padStart(2,'0') + 'M';\n                })()\n            }\">\n                <div style=\"color:#ddd;font-size:.8em\">{{k}}</div>\n                <div style=\"font-weight:700;font-size:1.3em\">{{v}}</div>\n            </div>\n        </div>\n    </div>\n</div>",
        "storeOutMessages": true,
        "passthru": true,
        "templateScope": "local",
        "className": "",
        "x": 1010,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "09f010af7c5e1992",
        "type": "ui-template",
        "z": "e046a6ce6457b012",
        "g": "76fabc0223d5e539",
        "group": "group_static",
        "page": "",
        "ui": "",
        "name": "BMS 1 - STATIQUE BLEU",
        "order": 1,
        "width": 6,
        "height": 11,
        "format": "<div v-if=\"msg && msg.payload\" style=\"background:linear-gradient(135deg,#1e3c72 0%,#2a5298 100%);border-radius:15px;padding:15px;font-family:'Segoe UI',sans-serif;min-height:100%\">\n    <div style=\"display:grid;grid-template-columns:1fr 1fr;gap:15px\">\n        <!-- Section Configuration - 1ère colonne -->\n        <div style=\"background:rgba(255,255,255,0.3); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.3); border-radius:12px; padding:20px; box-shadow:0 8px 32px rgba(0,0,0,0.1)\">\n            <h2 style=\"margin:0 0 15px 0; border-bottom:2px solid rgba(0,0,0,0.1); padding-bottom:10px; color:#000; font-size:1.4em\">♒ BMS #1 - Configuration</h2>\n            <div v-for=\"(val, label) in {\n                'Modèle': msg.payload.modele,\n                'Série': msg.payload.serie,\n                'Firmware': msg.payload.firmware,\n                'Software': msg.payload.software,\n                'Démarrages': msg.payload.powerCount,\n                'Uptime': msg.payload.uptime,\n                'Date Fab.': msg.payload.dateFab,\n                'Charge Req': msg.payload.params.chargeV+'V',\n                'Buzzer ON': msg.payload.buzzer.trigger+'%',\n                'Buzzer OFF': msg.payload.buzzer.release+'%'\n            }\" style=\"display:flex; justify-content:space-between; padding:10px 0; border-bottom:1px solid rgba(0,0,0,0.05); color:#000\">\n                <span style=\"font-weight:600; opacity:0.7\">{{label}}</span>\n                <span style=\"font-weight:800\">{{val}}</span>\n            </div>\n        </div>\n\n        <!-- Section Ko-fi - 2ème colonne -->\n        <div style=\"background:rgba(255,255,255,0.3); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.3); border-radius:12px; padding:20px; box-shadow:0 8px 32px rgba(0,0,0,0.1); display:flex; flex-direction:column; justify-content:center; align-items:center; gap:15px\">\n            <h2 style=\"margin:0; border-bottom:2px solid rgba(0,0,0,0.1); padding-bottom:10px; color:#000; font-size:1.4em; width:100%; text-align:center\">☕ Support</h2>\n            <div style=\"color:#000; font-size:1.2em; font-weight:600\">Support me on Ko-fi</div>\n            <a href='https://ko-fi.com/Y8Y3YHYZP' target='_blank' style=\"display:flex;justify-content:center\"><img height='60' style='border:0px;height:60px;' src='https://storage.ko-fi.com/cdn/kofi6.png?v=6' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a>\n        </div>\n    </div>\n</div>",
        "storeOutMessages": true,
        "passthru": true,
        "templateScope": "local",
        "className": "",
        "x": 890,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "1dc7d19597d60885",
        "type": "function",
        "z": "e046a6ce6457b012",
        "g": "3909cc6b3670d838",
        "name": "Formatage Settings BMS",
        "func": "// Récupération de l'ID du BMS\nconst bmsId = msg.payload.Device_address_N || \"1\";\n\n// On attache l'ID au message pour le switch\nmsg.bmsAddress = bmsId.toString();\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 240,
        "wires": [
            [
                "73a9586798828b06"
            ]
        ]
    },
    {
        "id": "73a9586798828b06",
        "type": "switch",
        "z": "e046a6ce6457b012",
        "g": "3909cc6b3670d838",
        "name": "Trier Settings par BMS",
        "property": "bmsAddress",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "2",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 700,
        "y": 240,
        "wires": [
            [
                "020632fc8339b4f3"
            ],
            []
        ]
    },
    {
        "id": "87a73731e478e29a",
        "type": "link in",
        "z": "e046a6ce6457b012",
        "g": "3909cc6b3670d838",
        "name": "Dashboard-Settings-Data-In",
        "links": [
            "96189c0a78b84915"
        ],
        "x": 255,
        "y": 240,
        "wires": [
            [
                "1dc7d19597d60885"
            ]
        ]
    },
    {
        "id": "020632fc8339b4f3",
        "type": "ui-template",
        "z": "e046a6ce6457b012",
        "g": "3909cc6b3670d838",
        "group": "6af349ba04c1ad8a",
        "page": "",
        "ui": "",
        "name": "BMS 1 - SETTINGS BLEU",
        "order": 1,
        "width": "12",
        "height": "10",
        "format": "<div v-if=\"msg && msg.payload\" style=\"font-family:'Segoe UI',sans-serif;background:linear-gradient(135deg,#1e3c72 0%,#2a5298 100%);min-height:100vh;padding:20px;margin:-20px\">\n    <div style=\"max-width:1400px;margin:0 auto\">\n        \n        <div style=\"color:#fff;margin-bottom:20px;display:flex;justify-content:center;align-items:baseline;gap:20px;text-shadow: 0 2px 4px rgba(0,0,0,0.2)\">\n            <h1 style=\"font-size:2em;margin:0\">⚙️ Settings BMS #1</h1>\n            <span style=\"opacity:.9;font-size:1em;font-weight:300\">Lecture seule</span>\n        </div>\n\n        <div style=\"display:grid;grid-template-columns:repeat(auto-fit, minmax(340px, 1fr));gap:20px\">\n            \n            <div style=\"background:rgba(255,255,255,0.25); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.3); border-radius:15px; padding:15px; box-shadow:0 8px 32px rgba(0,0,0,0.15)\">\n                <h3 style=\"color:#000;border-bottom:2px solid rgba(0,0,0,0.1);padding-bottom:5px;margin:0 0 10px 0\">⚡ Tensions Cellules</h3>\n                <table style=\"width:100%;font-size:0.85em;border-collapse:collapse;color:#000\">\n                    <tr v-for=\"(val, key) in {\n                        'Overvoltage Prot.': msg.payload.cell_voltage_overvoltage_protection_V + 'V',\n                        'Overvoltage Recov.': msg.payload.cell_voltage_overvoltage_recovery_V + 'V',\n                        'Undervoltage Prot.': msg.payload.cell_voltage_undervoltage_protection_V + 'V',\n                        'Undervoltage Recov.': msg.payload.cell_voltage_undervoltage_recovery_V + 'V',\n                        'Request Charge': msg.payload.cell_request_charge_voltage_V + 'V',\n                        'Float Voltage': msg.payload.cell_request_float_voltage_V + 'V',\n                        'Smart Sleep': msg.payload.smart_sleep_voltage_V + 'V'\n                    }\" style=\"border-bottom:1px solid rgba(0,0,0,0.05)\">\n                        <td style=\"padding:6px 0;opacity:0.7;font-weight:600\">{{key}}</td>\n                        <td style=\"padding:6px 0;text-align:right;font-weight:800\">{{val}}</td>\n                    </tr>\n                </table>\n            </div>\n\n            <div style=\"background:rgba(255,255,255,0.25); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.3); border-radius:15px; padding:15px; box-shadow:0 8px 32px rgba(0,0,0,0.15)\">\n                <h3 style=\"color:#000;border-bottom:2px solid rgba(0,0,0,0.1);padding-bottom:5px;margin:0 0 10px 0\">🔌 Courant & Protections</h3>\n                <table style=\"width:100%;font-size:0.85em;border-collapse:collapse;color:#000\">\n                    <thead><tr style=\"opacity:0.6;font-size:0.8em\"><th align=\"left\">Paramètre</th><th align=\"right\">Valeur</th><th align=\"right\">Délai</th></tr></thead>\n                    <tr style=\"border-bottom:1px solid rgba(0,0,0,0.05)\">\n                        <td style=\"padding:6px 0;font-weight:600\">Overcurrent Charge</td>\n                        <td align=\"right\" style=\"font-weight:800\">{{msg.payload.max_charge_current_A}}A</td>\n                        <td align=\"right\" style=\"color:#92400e;font-weight:700\">{{msg.payload.charge_overcurrent_protection_delay_S}}s</td>\n                    </tr>\n                    <tr style=\"border-bottom:1px solid rgba(0,0,0,0.05)\">\n                        <td style=\"padding:6px 0;font-weight:600\">Overcurrent Disch.</td>\n                        <td align=\"right\" style=\"font-weight:800\">{{msg.payload.max_discharge_current_S}}A</td>\n                        <td align=\"right\" style=\"color:#92400e;font-weight:700\">{{msg.payload.discharge_overcurrent_protection_delay_S}}s</td>\n                    </tr>\n                    <tr v-for=\"(val, key) in {\n                        'Max Balance Current': msg.payload.max_balance_current_A + 'A',\n                        'Balance Start': msg.payload.balance_starting_voltage_V + 'V',\n                        'Balance Trigger': msg.payload.balance_trigger_voltage_V + 'V'\n                    }\" style=\"border-bottom:1px solid rgba(0,0,0,0.05)\">\n                        <td style=\"padding:6px 0;opacity:0.7;font-weight:600\">{{key}}</td>\n                        <td colspan=\"2\" align=\"right\" style=\"font-weight:800\">{{val}}</td>\n                    </tr>\n                </table>\n            </div>\n\n            <div style=\"background:rgba(255,255,255,0.25); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.3); border-radius:15px; padding:15px; box-shadow:0 8px 32px rgba(0,0,0,0.15)\">\n                <h3 style=\"color:#000;border-bottom:2px solid rgba(0,0,0,0.1);padding-bottom:5px;margin:0 0 10px 0\">🌡️ Temp. & Système</h3>\n                <table style=\"width:100%;font-size:0.85em;border-collapse:collapse;color:#000\">\n                    <tr v-for=\"(val, key) in {\n                        'Charge High/Recov': msg.payload.charge_overtemperature_protection_T + ' / ' + msg.payload.charge_overtemperature_protection_recovery_T + '°C',\n                        'Discharge High/Recov': msg.payload.discharge_overtemperature_protection_T + ' / ' + msg.payload.discharge_overtemperature_protection_recovery_T + '°C',\n                        'Capacité Nominale': msg.payload.total_battery_capacity_Ah + ' Ah',\n                        'Nombre Cellules': msg.payload.cell_count_N\n                    }\" style=\"border-bottom:1px solid rgba(0,0,0,0.05)\">\n                        <td style=\"padding:6px 0;opacity:0.7;font-weight:600\">{{key}}</td>\n                        <td align=\"right\" style=\"font-weight:800\">{{val}}</td>\n                    </tr>\n                </table>\n                <div style=\"display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:15px\">\n                    <div v-for=\"(val, key) in {'Charge':msg.payload.charging_switch_B, 'Discharge':msg.payload.discharging_switch_B, 'Equilibrage':msg.payload.balance_switch_B}\" \n                         :style=\"{background:val?'#10b981':'#ef4444'}\" style=\"padding:8px;border-radius:8px;text-align:center;color:white;font-weight:bold;font-size:0.75em;box-shadow: 0 2px 4px rgba(0,0,0,0.2)\">\n                        {{key}}\n                    </div>\n                </div>\n            </div>\n\n            <div style=\"background:rgba(255,255,255,0.25); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.3); border-radius:15px; padding:15px; box-shadow:0 8px 32px rgba(0,0,0,0.15); display:flex; flex-direction:column; justify-content:center; align-items:center; gap:15px\">\n                <h3 style=\"color:#000;border-bottom:2px solid rgba(0,0,0,0.1);padding-bottom:5px;margin:0; width:100%;text-align:center\">☕ Support</h3>\n                <div style=\"color:#000; font-size:1.2em; font-weight:600\">Support me on Ko-fi</div>\n                <a href='https://ko-fi.com/Y8Y3YHYZP' target='_blank' style=\"display:flex;justify-content:center\"><img height='60' style='border:0px;height:60px;' src='https://storage.ko-fi.com/cdn/kofi6.png?v=6' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a>\n            </div>\n\n        </div>\n    </div>\n</div>",
        "storeOutMessages": true,
        "passthru": true,
        "templateScope": "local",
        "className": "",
        "x": 960,
        "y": 240,
        "wires": [
            []
        ]
    }
]